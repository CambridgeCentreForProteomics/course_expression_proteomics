{
  "hash": "dcf44f63cd071042c54f967f052c55c3",
  "result": {
    "markdown": "---\ntitle: Import and infrastructure\nbibliography: course_refs.bib\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related\n* Know how to import data into a `QFeatures` object \n* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/flow_chart/flow_chart.001.png){fig-align='center' width=90%}\n:::\n:::\n\n\n## The data structure\n\nMS-based quantitative proteomics data is typically represented as a matrix in\nwhich the rows represent features (PSMs, peptides or proteins) and the columns\ncontain information about these features, including their quantification\nmeasurements across several samples. As we saw before, this type of quantitative\nproteomics matrix can be generated by using third party softwares to process raw\nMS data. Moreover, the software usually outputs a quantitative matrix for each\ndata level (e.g., PSM, peptide, peptide groups, protein groups). In this lesson\nwe will explain how we can make use of R/Bioconductor packages with dedicated\nfunctions and data structures to store and manipulate quantitative proteomics\ndata.\n\nWe begin with exporting our data at the lowest data-level. In this DDA TMT\nexperiment this is the PSM level. This .txt file contains for every PSM\nidentified the relative abundance of each PSMs across each sample as well\nas columns with PSM meta-data.\n\nWe will be using the Quantitative features for mass spectrometry, or\n`QFeatures`, Bioconductor package to import, store, and manipulate our data.\nBefore we import the data into R using `QFeatures` it is first necessary to\nunderstand the structure of a `QFeatures` object and `SummarizedExperiment`\nobject.\n\n## The structure of a `SummarizedExperiment`\n\nTo simplify the storage of quantitative proteomics data we can store the data as\na [`SummarizedExperiment`](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html)\nobject (as shown in @fig-summarized-experiment).`SummarizedExperiment` objects\ncan be conceptualised as data containers made up of three different parts:\n\n1. The `assay` - a matrix which contains the quantitative data from a proteomics\nexperiment. Each row represents a feature (a PSM, peptide or protein) and each\ncolumn contains the quantitative data (measurements) from one experimental\nsample.\n\n2. The `rowData` - a table (data frame) which contains all remaining\ninformation derived from an identification search (i.e. every column from your\nidentification search output that was not a quantification column). Rows \nrepresent features but columns inform about different attributes of the feature\n(e.g., its sequence, name, modifications).\n\n3. The `colData` - an table (data frame) to store sample metadata that would not\nappear in the output of your identification search. This could be for example,\nthe cell line used, which condition, which replicate each sample corresponds to\netc. Again, this information is stored in a matrix-like data structure.\n\nFinally, there is also an additional container called `metadata` which is a\nplace for users to store experimental metadata. For example, this could be which\ninstrument the samples were run on, the operators name, the date the samples\nwere run and so forth. We will focus on populating and understanding the above\n3 main containers within a `SummarizedExperiment`. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Diagramatic representation of the structure of a `SummarizedExperiment` object in R (modified from the SummarizedExperiment package)](figs/summarized-experiment-modified.png){#fig-summarized-experiment fig-align='center' width=90%}\n:::\n:::\n\n\nData stored in these three main areas can be easily accessed using the `assay()`, \n`rowData()` and `colData()` functions, as we will see later.\n\n\n## The structure of a `QFeatures` object\n\nWhilst a `SummarizedExperiment` is able to neatly store quantitative proteomics\ndata at a single data level (i.e., PSM, peptide or protein), a typical data\nanalysis workflow requires us to look across multiple levels. For example, it is\ncommon to start an analysis with a lower data level and then aggregate upward\ntowards a final protein-level dataset. Doing this allows for greater flexibility\nand understanding of the processes required to clean and aggregate the data.\n\nA [`QFeatures`](https://bioconductor.org/packages/release/bioc/html/QFeatures.html) \nobject is essentially a list of `SummarizedExperiment` objects. However, the\nmain benefit of using a `QFeatures` object over storing each data level as an\nindependent `SummarizedExperiment` is that the `QFeatures` infrastructure\nmaintains explicit links between the `SummarizedExperiment`s that it stores.\nThis allows for maximum traceability when processing data across multiple levels\ne.g., tracking which PSMs contribute to each peptide and which peptides\ncontribute to a protein (@fig-qfeatures, modified from the [`QFeatures` vignette](https://bioconductor.org/packages/release/bioc/vignettes/QFeatures/inst/doc/QFeatures.html)\nwith permission).\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.](figs/qfeatures.png){#fig-qfeatures fig-align='center' width=90%}\n:::\n:::\n\n\n:::{.callout-note}\n#### QFeatures\nWhen talking about a `QFeatures` object, each dataset (individual\n`SummarizedExperiment`) can be referred to as an `experiment assay`. This is not\nto be confused with the quantitative matrix section of a `SummarizedExperiment`,\nwhich is also called the `assay` data.\n:::\n\nIn order to generate the explicit links between data levels, we need to import\nthe lowest desired data level into a `QFeatures` object and aggregate upwards\nwithin the `QFeatures` infrastructure using the `aggregateFeatures` function, as\nwe will later see in this course. If two `SummarizedExperiments` are generated\nseparately and then added into the same `QFeatures` object, there will not\nautomatically be links between them. In this case, if links are required, we can\nmanually add links using the `addAssayLink()` function.\n\nThe best way to get our head around the `QFeatures` infrastructure is to import\nour data into a `QFeatures` object and start exploring. \n\n\n## Packages and working directory\n\nDuring this course we will use several R/Bioconductor packages. \n\nLet's begin by opening RStudio and loading these packages into our working\nenvironment. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"QFeatures\")\nlibrary(\"NormalyzerDE\")\nlibrary(\"limma\")\nlibrary(\"factoextra\")\nlibrary(\"org.Hs.eg.db\")\nlibrary(\"clusterProfiler\")\nlibrary(\"enrichplot\")\nlibrary(\"patchwork\")\nlibrary(\"tidyverse\")\n```\n:::\n\n\nSet your working directory to xxx where you will find the `data` folder which\ncontains the material required for this course. This can be done by using the\n`setwd` function or by going to the menu Session -> Set Working Directory ->\nChoose Directory, in RStudio.\n\n## Importing data into R\n\nThere are several ways in which data can be imported into a `QFeatures` object.\nFor example, it is possible to first read the data into a `SummarizedExperiment`\nobject using the `readSummarizedExperiment()` function, and then import this\n`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can \nimport our data directly into a `QFeatures` object using the `readQFeatures()`\nfunction. We will use the latter.\n\nArguments to pass to `readQFeatures`:\n\n* `table` = file path to our data\n* `ecol` = an index for columns containing quantitative data. Can be a numeric \nindex of the columns or a character vector containing the column names\n* `sep` = the file delimiter used (`\\t` for tab-delimited `.txt` files and \n`,` for comma separated `.csv` files)\n* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`\nwithin the `QFeatures` object\n\nLet's read in the total proteome dataset from our experiment which is has been\noutput from Proteome Discoverer at the PSM level. The file is called\n`cell_cycle_total_proteome_analysis_PSMs.txt`. \n\nBefore we can read in the data we need to first identify which columns the\nquantitation data is stored in. The data is a `.txt` file is tab-delimited\nso we can use the `read.delim` function and look at the column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.delim(\"data/cell_cycle_total_proteome_analysis_PSMs.txt\") %>%\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                           \"Tags\"                             \n [3] \"Confidence\"                        \"Identifying.Node.Type\"            \n [5] \"Identifying.Node\"                  \"Search.ID\"                        \n [7] \"Identifying.Node.No\"               \"PSM.Ambiguity\"                    \n [9] \"Sequence\"                          \"Annotated.Sequence\"               \n[11] \"Modifications\"                     \"Number.of.Proteins\"               \n[13] \"Master.Protein.Accessions\"         \"Master.Protein.Descriptions\"      \n[15] \"Protein.Accessions\"                \"Protein.Descriptions\"             \n[17] \"Number.of.Missed.Cleavages\"        \"Charge\"                           \n[19] \"Original.Precursor.Charge\"         \"Delta.Score\"                      \n[21] \"Delta.Cn\"                          \"Rank\"                             \n[23] \"Search.Engine.Rank\"                \"Concatenated.Rank\"                \n[25] \"mz.in.Da\"                          \"MHplus.in.Da\"                     \n[27] \"Theo.MHplus.in.Da\"                 \"Delta.M.in.ppm\"                   \n[29] \"Delta.mz.in.Da\"                    \"Ions.Matched\"                     \n[31] \"Matched.Ions\"                      \"Total.Ions\"                       \n[33] \"Intensity\"                         \"Activation.Type\"                  \n[35] \"NCE.in.Percent\"                    \"MS.Order\"                         \n[37] \"Isolation.Interference.in.Percent\" \"SPS.Mass.Matches.in.Percent\"      \n[39] \"Average.Reporter.SN\"               \"Ion.Inject.Time.in.ms\"            \n[41] \"RT.in.min\"                         \"First.Scan\"                       \n[43] \"Last.Scan\"                         \"Master.Scans\"                     \n[45] \"Spectrum.File\"                     \"File.ID\"                          \n[47] \"Abundance.126\"                     \"Abundance.127N\"                   \n[49] \"Abundance.127C\"                    \"Abundance.128N\"                   \n[51] \"Abundance.128C\"                    \"Abundance.129N\"                   \n[53] \"Abundance.129C\"                    \"Abundance.130N\"                   \n[55] \"Abundance.130C\"                    \"Abundance.131\"                    \n[57] \"Quan.Info\"                         \"Peptides.Matched\"                 \n[59] \"XCorr\"                             \"Number.of.Protein.Groups\"         \n[61] \"Contaminant\"                       \"Percolator.q.Value\"               \n[63] \"Percolator.PEP\"                    \"Percolator.SVMScore\"              \n```\n:::\n:::\n\n\nWe can see the quantitation data is located in columns 47 - 56 which start with\n\"Abundance...\" followed by the identifying TMT tag. Naming of the abundance\ncolumns is dependent on the third party software used and version, please make\nsure you check you identify the relevent column numbers containing the\nquantitation data in your own data.\n\nWe will pass this information to the `ecol` argument when we use the\n`readQFeatures` function. As already mentioned, the `.txt` file is tab-delimited\nso we thus pass `sep = \"\\t\"`. As this is the first data import before any\nprocessing so let's call this data level `\"psms_raw\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Import data into QF object\ncc_qf <- readQFeatures(table = \"data/cell_cycle_total_proteome_analysis_PSMs.txt\",\n                       ecol = 47:56, \n                       sep = \"\\t\",\n                       name = \"psms_raw\")\n```\n:::\n\n\n\n::: {.callout-note}\n#### Finding help files\nDuring this course we see many new functions. For more information on any R\nfunction type `?` and the name of the function in the R console to bring up\nthe relevant documentation. Or go to the Help menu in RStudio and \nHelp -> Search R Help. For example, to see the help files and documentation for\nthe `readQFeatures` function type `?readQFeatures` in your RStudio console. The\nhelp documentation highlights what structure the input data should be (a vector,\ndataframe or matrix etc.) as well as which arguments are required or optional. \nWhen using more complex functions, such as those which we will use for statistical\nanalysis, it is advisable to consult the help documentation to ensure that you \nunderstand what the function's default parameters are. This will help you to\nmake sure that the function does what you are expecting it to do.\n\n:::\n\n\n## Accessing information within a `QFeatures` object\n\nLet's take a look at our newly created object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 1 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n```\n:::\n:::\n\n\nWe see that we have created a `QFeatures` object containing a single\n`SummarizedExperiment` called \"psms_raw\". There are 45803\nrows in the data, representing 45803 PSMs. We also see\nthat there are 10 columns representing our 10 samples.\n\nWe can access individual `SummarizedExperiment`s within a `QFeatures` object\nusing standard double bracket nomenclature (this is how you would normally\naccess items of a `list` in R). As with all indexing we can use the list\nposition or assay name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Indexing using position\ncc_qf[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 45803 10 \nmetadata(0):\nassays(1): ''\nrownames(45803): 1 2 ... 45802 45803\nrowData names(54): Checked Tags ... Percolator.PEP Percolator.SVMScore\ncolnames(10): Abundance.126 Abundance.127N ... Abundance.130C\n  Abundance.131\ncolData names(0):\n```\n:::\n\n```{.r .cell-code}\n## Indexing using name\ncc_qf[[\"psms_raw\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 45803 10 \nmetadata(0):\nassays(1): ''\nrownames(45803): 1 2 ... 45802 45803\nrowData names(54): Checked Tags ... Percolator.PEP Percolator.SVMScore\ncolnames(10): Abundance.126 Abundance.127N ... Abundance.130C\n  Abundance.131\ncolData names(0):\n```\n:::\n:::\n\n\nWithin each `SummarizedExperiment`(SE), the `rowData`, `colData` and `assay`\ndata are accessed using `rowData()`, `colData()` and `assay()`, respectively.\nLet's use these functions to explore the data structure further.\n\n- How has our data been organised within the `QFeatures` object? \n\n## The `assay` container\n\nLet's start with the quantitation data of our SE called `psms_raw`. This is\nstored in the `assay` slot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassay(cc_qf[[\"psms_raw\"]])\n```\n:::\n\n\nYou will see that the R console is populated with the quantitation data and the\nwhole dataset is too big to print to the screen. Let's use the `head` command to\nshow only the 6 lines (default) of the quantitation data.\n\nType into your R console,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(assay(cc_qf[[\"psms_raw\"]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Abundance.126 Abundance.127N Abundance.127C Abundance.128N Abundance.128C\n1          22.3           48.6           15.1           26.8           39.0\n2          19.8           31.3           14.1           19.5           32.1\n3           2.4            7.9            1.2            2.3            4.1\n4           2.2             NA             NA             NA             NA\n5           2.2            4.2            2.2            1.6            5.7\n6            NA            1.7             NA             NA             NA\n  Abundance.129N Abundance.129C Abundance.130N Abundance.130C Abundance.131\n1           21.6           41.6           38.7           21.2          34.7\n2           29.2           37.1           41.2           30.0          34.9\n3            1.0            3.6            7.0            3.1           2.7\n4            2.3            3.1             NA            1.7            NA\n5            1.4             NA            3.6            4.0           4.0\n6             NA             NA             NA             NA           2.7\n```\n:::\n:::\n\n\nThis is equivalent to,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf %>% \n  assay() %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Abundance.126 Abundance.127N Abundance.127C Abundance.128N Abundance.128C\n1          22.3           48.6           15.1           26.8           39.0\n2          19.8           31.3           14.1           19.5           32.1\n3           2.4            7.9            1.2            2.3            4.1\n4           2.2             NA             NA             NA             NA\n5           2.2            4.2            2.2            1.6            5.7\n6            NA            1.7             NA             NA             NA\n  Abundance.129N Abundance.129C Abundance.130N Abundance.130C Abundance.131\n1           21.6           41.6           38.7           21.2          34.7\n2           29.2           37.1           41.2           30.0          34.9\n3            1.0            3.6            7.0            3.1           2.7\n4            2.3            3.1             NA            1.7            NA\n5            1.4             NA            3.6            4.0           4.0\n6             NA             NA             NA             NA           2.7\n```\n:::\n:::\n\n\nThe first code chunk uses nested functions and the second uses pipes. Throughout\nthis course for ease of coding and clarity we will use pipes and where \nappropriate follow the `tidyverse` style of coding for clarity. \n\n::: {.callout-note}\n#### The dplyr pipe\nIn this course we will frequently use pipes, specifically the `dplyr` pipe part\nof the `dplyr` package and `tidyverse`. The pipe operator allows you to chain\ntogether multiple operations and code complex tasks in a more linear and\nunderstandable way, rather than having to nest multiple function calls or write\nmultiple lines of code. For more information see Hadley Wickham's Tidyverse at\n[https://www.tidyverse.org](https://www.tidyverse.org).\n\n:::\n\n:::{.callout-exercise}\n#### Challenge 1: Accessing information\n\n{{< level 1 >}}\n\n\n\nExplore the `QFeatures` object you have just created. \n\n1. How many assays do we currently have in the object? \n\n2. How many PSMs have been quantified in the data?\n\n3. How do you access and view the quantitation data i.e. the relative abundance \nof each PSM across the samples?\n\n\n::: {.callout-answer collapse=true}\n\n**Task 1**\n\nWhen we type the name of the the object `cc_qf` a summary of the data is \nprinted to the screen. This summary shows us a summary of the number of assays\nwe have in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 1 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n```\n:::\n:::\n\n\nSince a `QFeatures` object is a list of `SummarizedExperiment` objects, we can\nuse `length(cc_qf)` to check how many objects we have inside it\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(cc_qf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nAlternatively, we can also extract the list of experiments directly using\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexperiments(cc_qf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExperimentList class object of length 1:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns\n```\n:::\n:::\n\n\n----\n\n**Task 2**\n\nSimilarly, the object summary also tells us the number of PSMs. We can also\nextract the number of rows (PSMs in our case) for a given level (i.e. `psms_raw`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45803\n```\n:::\n:::\n\n\n----\n\n**Task 3**\n\nWe can use the `assay` accessor,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  assay()\n```\n:::\n\n\nor equivalently,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassay(cc_qf[[\"psms_raw\"]])\n```\n:::\n\n\n----\n\n:::\n:::\n\nAs expected, the `assay` slot contains 10 quantitative columns corresponding to\nthe 10 samples in our experiment. We see some quantitative values and some \nmissing values, here denotated `NA`.\n\n## The `rowData` container\n\nNow let's examine the the `rowData` slot,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                           \"Tags\"                             \n [3] \"Confidence\"                        \"Identifying.Node.Type\"            \n [5] \"Identifying.Node\"                  \"Search.ID\"                        \n [7] \"Identifying.Node.No\"               \"PSM.Ambiguity\"                    \n [9] \"Sequence\"                          \"Annotated.Sequence\"               \n[11] \"Modifications\"                     \"Number.of.Proteins\"               \n[13] \"Master.Protein.Accessions\"         \"Master.Protein.Descriptions\"      \n[15] \"Protein.Accessions\"                \"Protein.Descriptions\"             \n[17] \"Number.of.Missed.Cleavages\"        \"Charge\"                           \n[19] \"Original.Precursor.Charge\"         \"Delta.Score\"                      \n[21] \"Delta.Cn\"                          \"Rank\"                             \n[23] \"Search.Engine.Rank\"                \"Concatenated.Rank\"                \n[25] \"mz.in.Da\"                          \"MHplus.in.Da\"                     \n[27] \"Theo.MHplus.in.Da\"                 \"Delta.M.in.ppm\"                   \n[29] \"Delta.mz.in.Da\"                    \"Ions.Matched\"                     \n[31] \"Matched.Ions\"                      \"Total.Ions\"                       \n[33] \"Intensity\"                         \"Activation.Type\"                  \n[35] \"NCE.in.Percent\"                    \"MS.Order\"                         \n[37] \"Isolation.Interference.in.Percent\" \"SPS.Mass.Matches.in.Percent\"      \n[39] \"Average.Reporter.SN\"               \"Ion.Inject.Time.in.ms\"            \n[41] \"RT.in.min\"                         \"First.Scan\"                       \n[43] \"Last.Scan\"                         \"Master.Scans\"                     \n[45] \"Spectrum.File\"                     \"File.ID\"                          \n[47] \"Quan.Info\"                         \"Peptides.Matched\"                 \n[49] \"XCorr\"                             \"Number.of.Protein.Groups\"         \n[51] \"Contaminant\"                       \"Percolator.q.Value\"               \n[53] \"Percolator.PEP\"                    \"Percolator.SVMScore\"              \n```\n:::\n:::\n\n\nThe columns of our `rowData` contain non-quantitative information derived from \nthe third party identification search. The exact names of variables will differ\nbetween software and change over time, but the key information that we need to\nknow about each feature (here PSMs) will always be here. \n\nThis information includes the sequence of the peptide to which each PSM\ncorresponds (`\"Sequence\"`) as well as the master protein to which the peptide is\nassigned (`\"Master.Protein.Accessions\"`). We will come across more of the\nvariables stored in the `rowData` when we come to data cleaning and filtering.\n\nWe again use the `head` command to print the first 6 rows of the `rowData`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  head()\n```\n:::\n\n\n\n:::{.callout-exercise}\n#### Challenge 2: Calculating the number of peptides and proteins in our dataset\n\n{{< level 2 >}}\n\n\n\nExplore the information stored in the `rowData` from the Proteome Discoverer\nsearch. Look at the first few rows of this data matrix by using the `head`\nfunction and find a column that related to the peptide sequence information.\n\n1. What class is the `rowData` container? How many rows and columns are in \nthis data structure?\n\n2. Extract the `rowData` and convert it to a `tibble` or `data.frame`. Find a column that contains information that relates to the peptide sequence. Pull this information and calculate\nhow many unique peptide sequences we have in the dataset.\n\n<details><summary>Hint</summary> Using the `unique` function may be helpful.</details>\n\n3. How many proteins have been identified in the dataset? \n\n<details><summary>Hint</summary> Again, convert the `rowData` to a `tibble` or\n`data.frame` and find a column that contains information that relates to protein\nidentification.</details>\n\n::: {.callout-answer collapse=true}\n\n**Task 1**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  rowData() %>% \n  class()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"DFrame\"\nattr(,\"package\")\n[1] \"S4Vectors\"\n```\n:::\n:::\n\n\nWe see that the `rowData` is of class `\"DFrame\"`. This is a type of data frame.\nWill will convert this to a `data.frame` or `tibble` throughout this couse\nto make use of `tidyverse` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  rowData() %>% \n  dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45803    54\n```\n:::\n:::\n\n\nWe see we have 45803 PSMs and 54\ncolumns of information relating to each PSM.\n\n----\n\n**Task 2**\n\nThere are many ways to extract the number of peptides from our datasets. The\ncurrent data level shows the total number of PSMs (peptide spectrum matches).\nAlthough PSMs are fragments of identified peptide sequences, there can be many\nPSMs per unique peptide. The `rowData` is where we have stored information relating\nto our samples that are not quantitation data. The column `Sequence` contains \nthe peptide sequence from which the PSM is is derived. \n\nIn the following lines of code we,\n- Extract the `rowData`\n- Convert the `rowData` which is `DFrame` to either a `data.frame` or \n`tibble`. We could use the `as.data.frame` or `as_tibble` functions, \nrespectively, which we will allow us to use pipes. \n- Extract the column `Sequence`.\n- Use the `unique` function to group together PSMs from the same peptide. \n- Finally, we use the `length` command to count the number of peptides.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Using pipes\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(Sequence) %>%\n  unique() %>%\n  length() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26738\n```\n:::\n:::\n\n\nAlternative solution (among many others)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Without pipes\nrd <- rowData(cc_qf[[\"psms_raw\"]])\ntbl <- unique(rd$Sequence) \nlength(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26738\n```\n:::\n:::\n\n\nWe have 26738 peptides.\n\n----\n\n**Task 3**\n\nInformation regarding the proteins is found in the `Master.Protein.Accessions` column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Using pipes\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(Master.Protein.Accessions) %>%\n  unique() %>%\n  length() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5267\n```\n:::\n:::\n\n\nAlternative solution (among many others)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Without pipes\ntbl <- unique(rd$Master.Protein.Accessions) \nlength(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5267\n```\n:::\n:::\n\n\nWe have 5267 proteins.\n\n----\n\n:::\n:::\n\n## The `colData` container\n\nThe final slot within our `SummarizedExperiment` is the `colData`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  colData()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 0 columns\n```\n:::\n:::\n\n\nWe see this is also a `DataFrame` structure. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  colData() %>% \n  class()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"DFrame\"\nattr(,\"package\")\n[1] \"S4Vectors\"\n```\n:::\n:::\n\n\nIt has 10 rows, one per sample, but no columns yet. This is because the sample\nmetadata is not derived from an identification search and does not appear in our\noutput `.txt` file. If we want to store extra information about our samples, we\nneed to add this to the `colData` ourselves.\n\nEach row of this 10 by 0 `DataFrame` corresponds to some feature of the \nquantitation channel. The names of these rows are the TMT sample names,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  colData() %>% \n  rownames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Abundance.126\"  \"Abundance.127N\" \"Abundance.127C\" \"Abundance.128N\"\n [5] \"Abundance.128C\" \"Abundance.129N\" \"Abundance.129C\" \"Abundance.130N\"\n [9] \"Abundance.130C\" \"Abundance.131\" \n```\n:::\n:::\n\n\n## Annotating samples by adding meta-data\n\nThe `colData` contains information about the samples. We can create a\n`data.frame` in R with information regarding the samples, replicates, conditions\nand TMT tag used or we can read in this information into R from a spreadsheet or\n.csv. \n\nLet's open the file `coldata.csv` and then read it into R and add it to\nour `QFeatures` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Read in coldata .csv\nmetadata_df <- read.csv(\"data/samples_meta_data.csv\")\n\n## View data\nmetadata_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                X  sample rep     condition  tag\n1   Abundance.126 Control  NA Pre-treatment  126\n2  Abundance.127N     M_1   1             M 127N\n3  Abundance.127C     M_2   2             M 127C\n4  Abundance.128N     M_3   3             M 128N\n5  Abundance.128C    G1_1   1            G1 128C\n6  Abundance.129N    G1_2   2            G1 129N\n7  Abundance.129C    G1_3   3            G1 129C\n8  Abundance.130N    DS_1   1       Desynch 130N\n9  Abundance.130C    DS_2   2       Desynch 130C\n10  Abundance.131    DS_3   3       Desynch  131\n```\n:::\n:::\n\n\nThis .csv file has 10 rows, importantly the rows are annotated using the\nnames of the `rowData` of our object, e.g. \"Abundance.126\", \"Abundance.127N\" etc.\n\nWe can add information from this .csv to our `colData`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Annotate colData with condition information\ncc_qf$sample <- metadata_df$sample\n\n## Now add replicate information\ncc_qf$rep <- metadata_df$rep\n\n## And condition information\ncc_qf$condition <- metadata_df$condition\n\n## Add the TMT information\ncc_qf$tag <- metadata_df$tag\n\n## Verify\ncolData(cc_qf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 4 columns\n                    sample       rep     condition         tag\n               <character> <integer>   <character> <character>\nAbundance.126      Control        NA Pre-treatm...         126\nAbundance.127N         M_1         1             M        127N\nAbundance.127C         M_2         2             M        127C\nAbundance.128N         M_3         3             M        128N\nAbundance.128C        G1_1         1            G1        128C\nAbundance.129N        G1_2         2            G1        129N\nAbundance.129C        G1_3         3            G1        129C\nAbundance.130N        DS_1         1       Desynch        130N\nAbundance.130C        DS_2         2       Desynch        130C\nAbundance.131         DS_3         3       Desynch         131\n```\n:::\n\n```{.r .cell-code}\n## Apply this to the first assay so that it is carried up\ncolData(cc_qf[[\"psms_raw\"]]) <- colData(cc_qf)\n```\n:::\n\n\nWe can also change the names of our samples to simplify our downstream coding\nas well as our visualisation. This is done by changing the `colnames`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n ## Change col names to represent the sample\ncolnames(cc_qf[[\"psms_raw\"]]) <- cc_qf$sample\n\n## Verify\ncolData(cc_qf[[\"psms_raw\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 4 columns\n             sample       rep     condition         tag\n        <character> <integer>   <character> <character>\nControl     Control        NA Pre-treatm...         126\nM_1             M_1         1             M        127N\nM_2             M_2         2             M        127C\nM_3             M_3         3             M        128N\nG1_1           G1_1         1            G1        128C\nG1_2           G1_2         2            G1        129N\nG1_3           G1_3         3            G1        129C\nDS_1           DS_1         1       Desynch        130N\nDS_2           DS_2         2       Desynch        130C\nDS_3           DS_3         3       Desynch         131\n```\n:::\n:::\n\n\n\n\n\n:::{.callout-exercise}\n#### Challenge 3: Miscleavages\n\n{{< level 2 >}}\n\n\n\nOne of the pieces of information given by the Proteome Discoverer software used\nto produce the TMT data is the number of missed cleavages. This is stored in a\n`rowData` column named `\"Number.of.Missed.Cleavages\"`. Can you count how many\noccurrences of missed cleavages there are in our data?\n\n::: {.callout-answer collapse=true}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  count(Number.of.Missed.Cleavages)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 2\n  Number.of.Missed.Cleavages     n\n                       <int> <int>\n1                          0 34988\n2                          1  9709\n3                          2  1106\n```\n:::\n:::\n\n\nWe see that during the identification search missed cleavages were limited to a\nmaximum of 2 missed cleavage sites. This is typical in bottom-up proteomics.\n\n:::\n:::\n\n\n::: {.callout-tip}\n#### Key Points\n\n- The `QFeatures` infrastructure provides a convenient and transparent way to \nstore proteomics data across multiple levels.\n- A `QFeatures` object stores each data level as a `SummarizedExperiment`, \nalso called an `assay`, with explicit links maintained between features across \ndifferent `assay`s (e.g., links between all PSMs contributing to a peptide).\n- Explicit links between `assay`s are (i) generated automatically when \naggregating data using `aggregateFeatures` or (ii) added manually using the \n`addAssayLinks` function, as we will see later on.\n- Within each `SummarizedExperiment` the feature data is stored within the \n`rowData`, quantitative data in the `assay`, and sample metadata in the \n`colData`. These slots are accessible using their corresponding functions.\n:::\n\n## References {-}\n",
    "supporting": [
      "02_import_and_infrastructure_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}