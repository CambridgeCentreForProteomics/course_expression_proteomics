{
  "hash": "9da30711df5115354c72a7d41843c650",
  "result": {
    "markdown": "---\ntitle: Import and infrastructure\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related\n* Know how to import data into a `QFeatures` object \n* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`\n\n:::\n\n## The infrastructure\n\nMS-based quantitative proteomics data is typically represented as a matrix in \nwhich the rows represent features (PSMs, peptides or proteins) and the columns\ncontain information about these features, including their quantification \nmeasurements across several samples. As we saw before, this type of quantitative\nproteomics matrix can be generated by using third party softwares to process\nraw MS data. Moreover, the software usually outputs a quantitative matrix for \neach data level (e.g., PSM, peptide, peptide groups, protein groups).\n\n### The structure of a `SummarizedExperiment`\n\nA commonly used representation of these matrices in R is the `SummarizedExperiment`\nstructure (as shown in Figure \\@ref(fig:summarized-experiment)). To simplify the\nstorage of such complex data, `SummarizedExperiment` objects can be conceptualised\nas data containers made up of three different areas:\n\n1. The `assay` - a matrix-like data structure which contains the quantitative \ndata from a proteomics experiment. Each row represents a feature (PSM, peptide or\nprotein) and each column contains the quantitative data from one experimental \nsample.\n\n2. The `rowData` - a second matrix-like data structure which contains all remaining\ninformation derived from an identification search (i.e., every column from your\nidentification search output that was not a quantification column). Rows \nrepresent features but columns inform about different attributes of the feature\n(e.g., its sequence, name, modifications).\n\n3. The `colData` - an additional area to store sample metadata that would\nnot appear in the output of your identification search (e.g., which condition\nor replicate each sample corresponds to).\n\nThere is also an additional `metadata` compartment for users who wish to store\nexperimental metadata.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Diagramatic representation of the structure of a `SummarizedExperiment` object in R](figs/summarized-experiment.png){fig-align='center' width=100%}\n:::\n:::\n\n\nData stored in these three areas can be easily accessed using the `assay()`, \n`rowData()` and `colData()` functions, as we will see later.\n\n\n### The structure of a `QFeatures` object\n\nWhilst a `SummarizedExperiment` is able to neatly store quantitative proteomics\ndata at a single data level (i.e., PSM, peptide or protein), a typical data\nanalysis workflow requires us to look across multiple levels. For example, it is\ncommon to start an analysis with a lower data level and then aggregate upward\ntowards a final protein-level dataset. Doing this allows for greater flexibility\nand understanding of the processes required to clean and aggregate the data.\n\nA `QFeatures` object is essentially a list of `SummarizedExperiment` objects.\nHowever, the main benefit of using a `QFeatures` object over storing each data\nlevel as an independent `SummarizedExperiment` is that the `QFeatures` \ninfrastructure maintains explicit links between the `SummarizedExperiment`s that \nit stores. This allows for maximum traceability when processing data across \nmultiple levels e.g., tracking which PSMs contribute to each peptide and which \npeptides contribute to a protein.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nknitr::include_graphics(\"figs/qfeatures.png\", error = FALSE)\n```\n\n::: {.cell-output-display}\n![Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.](figs/qfeatures.png){fig-align='center' width=100%}\n:::\n:::\n\n\n**Note**\nWhen talking about a `QFeatures` object, each dataset (individual `SummarizedExperiment`)\ncan be referred to as an `assay`. This is not to be confused with the quantitative\nmatrix section of a `SummarizedExperiment`, which is also called the `assay` data.\n\nIn order to generate the explicit links between data levels, we need to import\nthe lowest desired data level into a `QFeatures` object and aggregate upwards\nwithin the `QFeatures` infrastructure using the `aggregateFeatures` function,\nas we will later in this course. If two `SummarizedExperiments` are generated \nseparately and then added into the same `QFeatures` object, there will not\nautomatically be links between them. In this case, if links are required, we\ncan manually add links using the `addAssayLink()` function.\n\nThe best way to get our head around the `QFeatures` infrastructure is to import\nour data into a `QFeatures` object and start exploring. \n\n## Working with `QFeatures` in R\n\n### Packages \n\nDuring this course we will use several R/Bioconductor packages. \n\nLet's begin by opening RStudio and loading these packages into our working\nenvironment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"QFeatures\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'MatrixGenerics' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'GenomicRanges' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'S4Vectors' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'IRanges' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'GenomeInfoDb' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"ggplot2\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggplot2' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"stringr\")\nlibrary(\"dplyr\")\nlibrary(\"tibble\")\nlibrary(\"NormalyzerDE\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'NormalyzerDE' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"corrplot\")\nlibrary(\"Biostrings\")\nlibrary(\"limma\")\nlibrary(\"statmod\")\nlibrary(\"org.Hs.eg.db\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'AnnotationDbi' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"clusterProfiler\")\nlibrary(\"enrichplot\")\n```\n:::\n\n\n### Working directory\n\nSet your working directory to xxx where you will find the material required for\nthis course.\n\n### Importing data into R\n\nThere are several ways in which data can be imported into a `QFeatures` object.\nFor example, it is possible to first read the data into a `SummarizedExperiment`\nobject using the `readSummarizedExperiment()` function, and the import this\n`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can \nimport our data directly into a `QFeatures` object using the `readQFeatures()`\nfunction.\n\nArguments to pass to `readQFeatures`:\n\n* `table` = file path to our data\n* `ecol` = an index for columns containing quantitative data. Can be a numeric \nindex of the columns or a character vector containing the column names\n* `sep` = the file delimiter used (`\\t` for `.txt` files and `,` for `.csv` files)\n* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`\nwithin the `QFeatures` object\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Import data into QF object\ncc_qf <- readQFeatures(table = \"data/cell_cycle_total_proteome_analysis_PSMs.txt\",\n                    ecol = 47:56, \n                    sep = \"\\t\",\n                    name = \"psms_raw\")\n```\n:::\n\n\n\n### Accessing information within a `QFeatures` object\n\nLet's take a look at our newly created object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Verify\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 1 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n```\n:::\n:::\n\n\nWe see that we have created a `QFeatures` object containing a single\n`SummarizedExperiment` called \"psms_raw\". There are 45803\nrows in the data, representing 45803 PSMs. We also see\nthat there are 10 columns representing our 10 samples.\n\nWe can access individual `SummarizedExperiment`s within a `QFeatures` object\nusing standard double bracket nomenclature (this is how you would normally\naccess items of a `list`). As with all indexing we can use the list position or\nassay name. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Indexing using position\ncc_qf[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 45803 10 \nmetadata(0):\nassays(1): ''\nrownames(45803): 1 2 ... 45802 45803\nrowData names(54): Checked Tags ... Percolator.PEP Percolator.SVMScore\ncolnames(10): Abundance.126 Abundance.127N ... Abundance.130C\n  Abundance.131\ncolData names(0):\n```\n:::\n\n```{.r .cell-code}\n## Indexing using name\ncc_qf[[\"psms_raw\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 45803 10 \nmetadata(0):\nassays(1): ''\nrownames(45803): 1 2 ... 45802 45803\nrowData names(54): Checked Tags ... Percolator.PEP Percolator.SVMScore\ncolnames(10): Abundance.126 Abundance.127N ... Abundance.130C\n  Abundance.131\ncolData names(0):\n```\n:::\n:::\n\n\nWithin each `SummarizedExperiment, the rowData, colData and assay data are\naccessed using `rowData()`, `colData()` and `assay()`, respectively. Let's use\nthese functions to explore the data structure further.\n\n\n### How has our data been organised within the `QFeatures` object? \n\nAs outlined above, each `SummarizedExperiment` within the `QFeatures` object \nhas a `rowData` slot. Let's take a look at the data stored here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Look at rowData\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  class()\n```\n:::\n\n\nThe `rowData` is of class `DFrame`. `DFrame` structures behave very similarly to\nthe base-R `data.frame`. Now let's see what columns our `DFrame` contains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Look at rowData\ncc_qf[[\"psms_raw\"]] %>%\n  rowData %>%\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                           \"Tags\"                             \n [3] \"Confidence\"                        \"Identifying.Node.Type\"            \n [5] \"Identifying.Node\"                  \"Search.ID\"                        \n [7] \"Identifying.Node.No\"               \"PSM.Ambiguity\"                    \n [9] \"Sequence\"                          \"Annotated.Sequence\"               \n[11] \"Modifications\"                     \"Number.of.Proteins\"               \n[13] \"Master.Protein.Accessions\"         \"Master.Protein.Descriptions\"      \n[15] \"Protein.Accessions\"                \"Protein.Descriptions\"             \n[17] \"Number.of.Missed.Cleavages\"        \"Charge\"                           \n[19] \"Original.Precursor.Charge\"         \"Delta.Score\"                      \n[21] \"Delta.Cn\"                          \"Rank\"                             \n[23] \"Search.Engine.Rank\"                \"Concatenated.Rank\"                \n[25] \"mz.in.Da\"                          \"MHplus.in.Da\"                     \n[27] \"Theo.MHplus.in.Da\"                 \"Delta.M.in.ppm\"                   \n[29] \"Delta.mz.in.Da\"                    \"Ions.Matched\"                     \n[31] \"Matched.Ions\"                      \"Total.Ions\"                       \n[33] \"Intensity\"                         \"Activation.Type\"                  \n[35] \"NCE.in.Percent\"                    \"MS.Order\"                         \n[37] \"Isolation.Interference.in.Percent\" \"SPS.Mass.Matches.in.Percent\"      \n[39] \"Average.Reporter.SN\"               \"Ion.Inject.Time.in.ms\"            \n[41] \"RT.in.min\"                         \"First.Scan\"                       \n[43] \"Last.Scan\"                         \"Master.Scans\"                     \n[45] \"Spectrum.File\"                     \"File.ID\"                          \n[47] \"Quan.Info\"                         \"Peptides.Matched\"                 \n[49] \"XCorr\"                             \"Number.of.Protein.Groups\"         \n[51] \"Contaminant\"                       \"Percolator.q.Value\"               \n[53] \"Percolator.PEP\"                    \"Percolator.SVMScore\"              \n```\n:::\n:::\n\n\nThe columns of our `rowData` contain non-quantitative information derived from \nthe third party identification search. The exact names of variables will differ\nbetween software and change over time, but the key information that we need to\nknow about each feature (here PSMs) will always be here. This information \nincludes the sequence of the peptide to which each PSM corresponds (`\"Sequence\"`)\nas well as the master protein to which the peptide is assigned (`\"Master.Protein.Accessions\"`).\nWe will come across more of the variables stored in the `rowData` when we come\nto data cleaning and filtering.\n\nWe can also take a look at the `assay` data that we have within our \"psms_raw\"\n`SummarizedExperiment`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  assay() %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Abundance.126 Abundance.127N Abundance.127C Abundance.128N Abundance.128C\n1          22.3           48.6           15.1           26.8           39.0\n2          19.8           31.3           14.1           19.5           32.1\n3           2.4            7.9            1.2            2.3            4.1\n4           2.2             NA             NA             NA             NA\n5           2.2            4.2            2.2            1.6            5.7\n6            NA            1.7             NA             NA             NA\n  Abundance.129N Abundance.129C Abundance.130N Abundance.130C Abundance.131\n1           21.6           41.6           38.7           21.2          34.7\n2           29.2           37.1           41.2           30.0          34.9\n3            1.0            3.6            7.0            3.1           2.7\n4            2.3            3.1             NA            1.7            NA\n5            1.4             NA            3.6            4.0           4.0\n6             NA             NA             NA             NA           2.7\n```\n:::\n:::\n\n\nAs expected, the `assay` slot contains 10 quantitative columns corresponding to\nthe 10 samples in our experiment. We see some quantitative values and some \nmissing values, here denotated `NA`.\n\nThe final slot within our `SummarizedExperiment` is the `colData`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  colData()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 0 columns\n```\n:::\n:::\n\n\nWe have a `DataFrame` structure with 10 rows, one per sample, but no columns yet. \nThis is because the sample metadata is not derived from an identification \nsearch and does not appear in our output `.txt` file. If we want to store extra\ninformation about our samples, we need to add this to the `colData` ourselves.\n\n\n### Annotating samples by adding meta-data to the `colData`\n\nWe can add columns to the `colData` using the `$` operator in the same way as \na normal `data.frame`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Annotate colData with replicate and condition\ncc_qf$sample <- c(\"Control\", \"M_1\", \"M_2\", \"M_3\",\n                  \"G1_1\", \"G1_2\", \"G1_3\",\n                  \"DS_1\", \"DS_2\", \"DS_3\")\n\ncc_qf$rep <- c(NA, rep(1:3, 3))\n\ncc_qf$condition <- c(\"Pre-treatment\", rep(c(\"M\", \"G1\", \"Desynch\"), each = 3))\n\n## Verify\ncolData(cc_qf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 3 columns\n                    sample       rep     condition\n               <character> <integer>   <character>\nAbundance.126      Control        NA Pre-treatm...\nAbundance.127N         M_1         1             M\nAbundance.127C         M_2         2             M\nAbundance.128N         M_3         3             M\nAbundance.128C        G1_1         1            G1\nAbundance.129N        G1_2         2            G1\nAbundance.129C        G1_3         3            G1\nAbundance.130N        DS_1         1       Desynch\nAbundance.130C        DS_2         2       Desynch\nAbundance.131         DS_3         3       Desynch\n```\n:::\n\n```{.r .cell-code}\n## Apply this to the first assay so that it is carried up\ncolData(cc_qf[[\"psms_raw\"]]) <- colData(cc_qf)\n```\n:::\n\n\nWe can also change the names of our samples to simplify our downstream coding\nas well as our visualisation. This is done by changing the `colnames`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n ## Change col names to represent the sample\ncolnames(cc_qf[[\"psms_raw\"]]) <- cc_qf$sample\n\n## Verify\ncolData(cc_qf[[\"psms_raw\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 3 columns\n             sample       rep     condition\n        <character> <integer>   <character>\nControl     Control        NA Pre-treatm...\nM_1             M_1         1             M\nM_2             M_2         2             M\nM_3             M_3         3             M\nG1_1           G1_1         1            G1\nG1_2           G1_2         2            G1\nG1_3           G1_3         3            G1\nDS_1           DS_1         1       Desynch\nDS_2           DS_2         2       Desynch\nDS_3           DS_3         3       Desynch\n```\n:::\n:::\n\n\n\n\n#### Challenge: Accessing information from a `QFeatures` object\n\n* Determine how many PSMs, peptides and master proteins are within the data\n* Work out what the threshold for trypsin miscleavages was during the identification search\n\n\n::: {.callout-tip}\n#### Key Points\n\n- The `QFeatures` infrastructure provides a convenient and transparent way to store proteomics data across multiple levels.\n- A `QFeatures` object stores each data level as a `SummarizedExperiment`, also called an `assay`, with explicit links maintained between features across different `assay`s (e.g., links between all PSMs contributing to a peptide).\n- Explicit links between `assay`s are (i) generated automatically when aggregating data using `aggregateFeatures` or (ii) added manually using the `addAssayLinks` function, as we will see later on.\n- Within each `SummarizedExperiment` the feature data is stored within the `rowData`, quantitative data in the `assay`, and sample metadata in the `colData`. These slots are accessible using their corresponding functions.\n:::\n",
    "supporting": [
      "02_import_and_infrastructure_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}