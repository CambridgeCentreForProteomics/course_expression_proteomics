{
  "hash": "8b8a4ba9196707eb8b07739b1f5c3aca",
  "result": {
    "markdown": "---\ntitle: Import and infrastructure\nbibliography: course_refs.bib\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related\n* Know how to import data into a `QFeatures` object \n* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`\n\n:::\n\n## The infrastructure\n\nMS-based quantitative proteomics data is typically represented as a matrix in \nwhich the rows represent features (PSMs, peptides or proteins) and the columns\ncontain information about these features, including their quantification \nmeasurements across several samples. As we saw before, this type of quantitative\nproteomics matrix can be generated by using third party softwares to process\nraw MS data. Moreover, the software usually outputs a quantitative matrix for \neach data level (e.g., PSM, peptide, peptide groups, protein groups).\n\n### The structure of a `SummarizedExperiment`\n\nA commonly used representation of these matrices in R is the `SummarizedExperiment`\nstructure (as shown in Figure \\@ref(fig:summarized-experiment)). To simplify the\nstorage of such complex data, `SummarizedExperiment` objects can be conceptualised\nas data containers made up of three different parts:\n\n1. The `assay` - a matrix-like data structure which contains the quantitative\ndata from a proteomics experiment. Each row represents a feature (a PSM, peptide\nor protein) and each column contains the quantitative data (measurements) from\none experimental sample.\n\n2. The `rowData` - a second matrix-like data structure which contains all remaining\ninformation derived from an identification search (i.e. every column from your\nidentification search output that was not a quantification column). Rows \nrepresent features but columns inform about different attributes of the feature\n(e.g., its sequence, name, modifications).\n\n3. The `colData` - an additional area to store sample metadata that would not\nappear in the output of your identification search. This could be for example,\nthe cell line used, which condition, which replicate each sample corresponds to\netc. Again, this information is stored in a matrix-like data structure.\n\nFinally, there is also the `metadata` slot which is a place for users to store\nexperimental metadata for example which instrument the samples were run on, the\noperators name, the date the samples were run and so forth.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Diagramatic representation of the structure of a `SummarizedExperiment` object in R](figs/summarized-experiment.png){fig-align='center' width=100%}\n:::\n:::\n\n\nData stored in these three main areas can be easily accessed using the `assay()`, \n`rowData()` and `colData()` functions, as we will see later.\n\n\n### The structure of a `QFeatures` object\n\nWhilst a `SummarizedExperiment` is able to neatly store quantitative proteomics\ndata at a single data level (i.e., PSM, peptide or protein), a typical data\nanalysis workflow requires us to look across multiple levels. For example, it is\ncommon to start an analysis with a lower data level and then aggregate upward\ntowards a final protein-level dataset. Doing this allows for greater flexibility\nand understanding of the processes required to clean and aggregate the data.\n\nA `QFeatures` object is essentially a list of `SummarizedExperiment` objects.\nHowever, the main benefit of using a `QFeatures` object over storing each data\nlevel as an independent `SummarizedExperiment` is that the `QFeatures` \ninfrastructure maintains explicit links between the `SummarizedExperiment`s that \nit stores. This allows for maximum traceability when processing data across \nmultiple levels e.g., tracking which PSMs contribute to each peptide and which \npeptides contribute to a protein.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.](figs/qfeatures.png){fig-align='center' width=100%}\n:::\n:::\n\n\n**Note**\nWhen talking about a `QFeatures` object, each dataset (individual `SummarizedExperiment`)\ncan be referred to as an `assay`. This is not to be confused with the quantitative\nmatrix section of a `SummarizedExperiment`, which is also called the `assay` data.\n\nIn order to generate the explicit links between data levels, we need to import\nthe lowest desired data level into a `QFeatures` object and aggregate upwards\nwithin the `QFeatures` infrastructure using the `aggregateFeatures` function,\nas we will later in this course. If two `SummarizedExperiments` are generated \nseparately and then added into the same `QFeatures` object, there will not\nautomatically be links between them. In this case, if links are required, we\ncan manually add links using the `addAssayLink()` function.\n\nThe best way to get our head around the `QFeatures` infrastructure is to import\nour data into a `QFeatures` object and start exploring. \n\n## Working with `QFeatures` in R\n\n### Packages \n\nDuring this course we will use several R/Bioconductor packages. \n\nLet's begin by opening RStudio and loading these packages into our working\nenvironment. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"QFeatures\")\nlibrary(\"ggplot2\")\nlibrary(\"stringr\")\nlibrary(\"dplyr\")\nlibrary(\"tibble\")\nlibrary(\"NormalyzerDE\")\nlibrary(\"corrplot\")\nlibrary(\"Biostrings\")\nlibrary(\"limma\")\nlibrary(\"statmod\")\nlibrary(\"factoextra\")\nlibrary(\"org.Hs.eg.db\")\nlibrary(\"clusterProfiler\")\nlibrary(\"enrichplot\")\nlibrary(\"patchwork\")\n```\n:::\n\n\n### Working directory {-}\n\nSet your working directory to xxx where you will find the `data` folder which\ncontains the material required for this course. This can be done by using the\n`setwd` function or by going to the menu Session -> Set Working Directory ->\nChoose Directory, in RStudio.\n\n### Importing data into R\n\nThere are several ways in which data can be imported into a `QFeatures` object.\nFor example, it is possible to first read the data into a `SummarizedExperiment`\nobject using the `readSummarizedExperiment()` function, and the import this\n`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can \nimport our data directly into a `QFeatures` object using the `readQFeatures()`\nfunction. We will use the latter.\n\nArguments to pass to `readQFeatures`:\n\n* `table` = file path to our data\n* `ecol` = an index for columns containing quantitative data. Can be a numeric \nindex of the columns or a character vector containing the column names\n* `sep` = the file delimiter used (`\\t` for tab-delimited `.txt` files and \n`,` for comma separated `.csv` files)\n* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`\nwithin the `QFeatures` object\n\nLet's read in the total proteome dataset from our experiment which is has been\noutput from Proteome Discoverer at the PSM level. The file is called\n`cell_cycle_total_proteome_analysis_PSMs.txt`. We will pass it to the\n`readQFeatures` function. The quantitation data is stored in columns 47 through\nto 56, this is passed to the `ecol` argument. The `.txt` file is tab-delimited\nso we pass `sep = \"\\t\"`. This is the first data import before any processing so\nlet's call this data level `\"psms_raw\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Import data into QF object\ncc_qf <- readQFeatures(table = \"data/cell_cycle_total_proteome_analysis_PSMs.txt\",\n                       ecol = 47:56, \n                       sep = \"\\t\",\n                       name = \"psms_raw\")\n```\n:::\n\n\n\n::: {.callout-note}\n#### Finding help files\nDuring this course we see many new functions. For more information on any R\nfunction type `?` and the name of the function in the R console to bring up\nthe relavent documentation. Or go to the Help menu in RStudio and \nHelp -> Search R Help. For example, to see the help files and documentation for\nthe `readQFeatures` function type `?readQFeatures` in your RStudio console.\n\n:::\n\n\n### Accessing information within a `QFeatures` object\n\nLet's take a look at our newly created object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 1 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n```\n:::\n:::\n\n\nWe see that we have created a `QFeatures` object containing a single\n`SummarizedExperiment` called \"psms_raw\". There are 45803\nrows in the data, representing 45803 PSMs. We also see\nthat there are 10 columns representing our 10 samples.\n\nWe can access individual `SummarizedExperiment`s within a `QFeatures` object\nusing standard double bracket nomenclature (this is how you would normally\naccess items of a `list` in R). As with all indexing we can use the list\nposition or assay name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Indexing using position\ncc_qf[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 45803 10 \nmetadata(0):\nassays(1): ''\nrownames(45803): 1 2 ... 45802 45803\nrowData names(54): Checked Tags ... Percolator.PEP Percolator.SVMScore\ncolnames(10): Abundance.126 Abundance.127N ... Abundance.130C\n  Abundance.131\ncolData names(0):\n```\n:::\n\n```{.r .cell-code}\n## Indexing using name\ncc_qf[[\"psms_raw\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SummarizedExperiment \ndim: 45803 10 \nmetadata(0):\nassays(1): ''\nrownames(45803): 1 2 ... 45802 45803\nrowData names(54): Checked Tags ... Percolator.PEP Percolator.SVMScore\ncolnames(10): Abundance.126 Abundance.127N ... Abundance.130C\n  Abundance.131\ncolData names(0):\n```\n:::\n:::\n\n\nWithin each `SummarizedExperiment`(SE), the `rowData`, `colData` and `assay`\ndata are accessed using `rowData()`, `colData()` and `assay()`, respectively.\nLet's use these functions to explore the data structure further.\n\n\n### How has our data been organised within the `QFeatures` object? \n\nLet's start with the quantitation data of our SE called `psms_raw`. This is\nstored in the `assay` slot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassay(cc_qf[[\"psms_raw\"]])\n```\n:::\n\n\nYou will see that the R console is populated with the quantitation data and the\nwhole dataset is too big to print to the screen. Let's use the `head` command to\nshow only the 6 lines (default) of the quantitation data.\n\nType into your R console,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(assay(cc_qf[[\"psms_raw\"]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Abundance.126 Abundance.127N Abundance.127C Abundance.128N Abundance.128C\n1          22.3           48.6           15.1           26.8           39.0\n2          19.8           31.3           14.1           19.5           32.1\n3           2.4            7.9            1.2            2.3            4.1\n4           2.2             NA             NA             NA             NA\n5           2.2            4.2            2.2            1.6            5.7\n6            NA            1.7             NA             NA             NA\n  Abundance.129N Abundance.129C Abundance.130N Abundance.130C Abundance.131\n1           21.6           41.6           38.7           21.2          34.7\n2           29.2           37.1           41.2           30.0          34.9\n3            1.0            3.6            7.0            3.1           2.7\n4            2.3            3.1             NA            1.7            NA\n5            1.4             NA            3.6            4.0           4.0\n6             NA             NA             NA             NA           2.7\n```\n:::\n:::\n\n\nThis is equivalent to,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf %>% \n  assay() %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Abundance.126 Abundance.127N Abundance.127C Abundance.128N Abundance.128C\n1          22.3           48.6           15.1           26.8           39.0\n2          19.8           31.3           14.1           19.5           32.1\n3           2.4            7.9            1.2            2.3            4.1\n4           2.2             NA             NA             NA             NA\n5           2.2            4.2            2.2            1.6            5.7\n6            NA            1.7             NA             NA             NA\n  Abundance.129N Abundance.129C Abundance.130N Abundance.130C Abundance.131\n1           21.6           41.6           38.7           21.2          34.7\n2           29.2           37.1           41.2           30.0          34.9\n3            1.0            3.6            7.0            3.1           2.7\n4            2.3            3.1             NA            1.7            NA\n5            1.4             NA            3.6            4.0           4.0\n6             NA             NA             NA             NA           2.7\n```\n:::\n:::\n\n\nThe first code chunk uses nested functions and the second uses pipes. Throughout\nthis course for ease of coding and clarity we will use pipes and where \nappropriate follow the `tidyverse` style of coding for clarity. \n\n::: {.callout-note}\n#### dplyr and tidyr\nIn this course we will frequently use pipes, specifically the `dplyr` pipe part\nof the `dplyr` packjage and `tidyverse`. The pipe operator allows you to link\ntogether multiple operations and code complex tasks in a more linear and\nunderstandable way, rather than having to nest multiple function calls or write\nmultiple lines of code. For more information see Hadley Wickham's Tidyverse at\n[https://www.tidyverse.org](https://www.tidyverse.org).\n\n:::\n\nAs expected, the `assay` slot contains 10 quantitative columns corresponding to\nthe 10 samples in our experiment. We see some quantitative values and some \nmissing values, here denotated `NA`.\n\nNow let's examine the the `rowData` slot,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData %>%\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                           \"Tags\"                             \n [3] \"Confidence\"                        \"Identifying.Node.Type\"            \n [5] \"Identifying.Node\"                  \"Search.ID\"                        \n [7] \"Identifying.Node.No\"               \"PSM.Ambiguity\"                    \n [9] \"Sequence\"                          \"Annotated.Sequence\"               \n[11] \"Modifications\"                     \"Number.of.Proteins\"               \n[13] \"Master.Protein.Accessions\"         \"Master.Protein.Descriptions\"      \n[15] \"Protein.Accessions\"                \"Protein.Descriptions\"             \n[17] \"Number.of.Missed.Cleavages\"        \"Charge\"                           \n[19] \"Original.Precursor.Charge\"         \"Delta.Score\"                      \n[21] \"Delta.Cn\"                          \"Rank\"                             \n[23] \"Search.Engine.Rank\"                \"Concatenated.Rank\"                \n[25] \"mz.in.Da\"                          \"MHplus.in.Da\"                     \n[27] \"Theo.MHplus.in.Da\"                 \"Delta.M.in.ppm\"                   \n[29] \"Delta.mz.in.Da\"                    \"Ions.Matched\"                     \n[31] \"Matched.Ions\"                      \"Total.Ions\"                       \n[33] \"Intensity\"                         \"Activation.Type\"                  \n[35] \"NCE.in.Percent\"                    \"MS.Order\"                         \n[37] \"Isolation.Interference.in.Percent\" \"SPS.Mass.Matches.in.Percent\"      \n[39] \"Average.Reporter.SN\"               \"Ion.Inject.Time.in.ms\"            \n[41] \"RT.in.min\"                         \"First.Scan\"                       \n[43] \"Last.Scan\"                         \"Master.Scans\"                     \n[45] \"Spectrum.File\"                     \"File.ID\"                          \n[47] \"Quan.Info\"                         \"Peptides.Matched\"                 \n[49] \"XCorr\"                             \"Number.of.Protein.Groups\"         \n[51] \"Contaminant\"                       \"Percolator.q.Value\"               \n[53] \"Percolator.PEP\"                    \"Percolator.SVMScore\"              \n```\n:::\n:::\n\n\nThe columns of our `rowData` contain non-quantitative information derived from \nthe third party identification search. The exact names of variables will differ\nbetween software and change over time, but the key information that we need to\nknow about each feature (here PSMs) will always be here. This information \nincludes the sequence of the peptide to which each PSM corresponds (`\"Sequence\"`)\nas well as the master protein to which the peptide is assigned (`\"Master.Protein.Accessions\"`).\nWe will come across more of the variables stored in the `rowData` when we come\nto data cleaning and filtering.\n\nWe again use the `head` command to print the first 6 rows of the `rowData`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  head()\n```\n:::\n\n\nThe final slot within our `SummarizedExperiment` is the `colData`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  colData()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 0 columns\n```\n:::\n:::\n\n\nWe have a `DataFrame` structure with 10 rows, one per sample, but no columns yet. \nThis is because the sample metadata is not derived from an identification \nsearch and does not appear in our output `.txt` file. If we want to store extra\ninformation about our samples, we need to add this to the `colData` ourselves.\n\nEach row of this 10 by 0 `DataFrame` corresponds to some feature of the \nquantitation channel. The names of these rows are the TMT sample names,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  colData() %>% \n  rownames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Abundance.126\"  \"Abundance.127N\" \"Abundance.127C\" \"Abundance.128N\"\n [5] \"Abundance.128C\" \"Abundance.129N\" \"Abundance.129C\" \"Abundance.130N\"\n [9] \"Abundance.130C\" \"Abundance.131\" \n```\n:::\n:::\n\n\n### Annotating samples by adding meta-data to the `colData`\n\nWe can add columns to the `colData` using the `$` operator in the same way as \na normal `data.frame`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Annotate colData with condition information\ncc_qf$sample <- c(\"Control\", \"M_1\", \"M_2\", \"M_3\",\n                  \"G1_1\", \"G1_2\", \"G1_3\",\n                  \"DS_1\", \"DS_2\", \"DS_3\")\n\n## Now add replicate information\ncc_qf$rep <- c(NA, rep(1:3, 3))\n\n## And condition information\ncc_qf$condition <- c(\"Pre-treatment\", rep(c(\"M\", \"G1\", \"Desynch\"), each = 3))\n\n## Add the TMT information\ncc_qf$tag <- colnames(cc_qf[[\"psms_raw\"]]) %>%\n  strsplit(split = \"Abundance.\") %>% \n  sapply(\"[[\", 2)\n\n## Verify\ncolData(cc_qf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 4 columns\n                    sample       rep     condition         tag\n               <character> <integer>   <character> <character>\nAbundance.126      Control        NA Pre-treatm...         126\nAbundance.127N         M_1         1             M        127N\nAbundance.127C         M_2         2             M        127C\nAbundance.128N         M_3         3             M        128N\nAbundance.128C        G1_1         1            G1        128C\nAbundance.129N        G1_2         2            G1        129N\nAbundance.129C        G1_3         3            G1        129C\nAbundance.130N        DS_1         1       Desynch        130N\nAbundance.130C        DS_2         2       Desynch        130C\nAbundance.131         DS_3         3       Desynch         131\n```\n:::\n\n```{.r .cell-code}\n## Apply this to the first assay so that it is carried up\ncolData(cc_qf[[\"psms_raw\"]]) <- colData(cc_qf)\n```\n:::\n\n\nWe can also change the names of our samples to simplify our downstream coding\nas well as our visualisation. This is done by changing the `colnames`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n ## Change col names to represent the sample\ncolnames(cc_qf[[\"psms_raw\"]]) <- cc_qf$sample\n\n## Verify\ncolData(cc_qf[[\"psms_raw\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 4 columns\n             sample       rep     condition         tag\n        <character> <integer>   <character> <character>\nControl     Control        NA Pre-treatm...         126\nM_1             M_1         1             M        127N\nM_2             M_2         2             M        127C\nM_3             M_3         3             M        128N\nG1_1           G1_1         1            G1        128C\nG1_2           G1_2         2            G1        129N\nG1_3           G1_3         3            G1        129C\nDS_1           DS_1         1       Desynch        130N\nDS_2           DS_2         2       Desynch        130C\nDS_3           DS_3         3       Desynch         131\n```\n:::\n:::\n\n\n\n\n## Exercises\n\n:::{.callout-exercise}\n#### Challenge 1: Accessing information\n\n{{< level 1 >}}\n\n\n\nExplore the `QFeatures` object you have just created. \n\n1. How many assays do we currently have in the object? \n\n2. How many PSMs have been quantified in the data?\n\n3. How do access and view the quantitation data?\n\n\n::: {.callout-answer collapse=true}\n\n**Task 1**\n\nWhen we type the name of the the object `cc_qf` a summary of the data is \nprinted to the screen. This summary shows us a summary of the number of assays\nwe have in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 1 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n```\n:::\n:::\n\n\nWe can check the number of `QFeatures` assays i.e. data levels by accessing\nthe `experimentList` slot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf@ExperimentList\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExperimentList class object of length 1:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns\n```\n:::\n:::\n\n\n----\n\n**Task 2**\n\nSimilarly, the object summary also tells us the number of PSMs. We can also\nextract the number of rows (PSMs in our case) for a given level (i.e. `psms_raw`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45803\n```\n:::\n:::\n\n\n----\n\n**Task 3**\n\nWe can use the `assay` accessor,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  assay()\n```\n:::\n\n\nor equivalently,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassay(cc_qf[[\"psms_raw\"]])\n```\n:::\n\n\n----\n\n:::\n:::\n\n\n\n:::{.callout-exercise}\n#### Challenge 2: Calculating the number of peptides and proteins in our dataset\n\n{{< level 2 >}}\n\n\n\nExplore the information stored in the `rowData` from the Proteome Discoverer\nsearch. Look at the first few rows of this data matrix by using the `head`\nfunction and find a column that related to the peptide sequence information.\n\n1. How many peptides have been quantified in the dataset?\n\n<details><summary>Hint 1</summary> Extract the `rowData` and convert it to a\n`tibble` or `data.frame`. Find a column that contains information that relates\nto the peptide sequence. The `unique` function may be helpful. </details>\n\n2. How many proteins have been identified in the dataset? \n\n<details><summary>Hint</summary> Again, convert the `rowData` to a `tibble` or\n`data.frame` and find a column that contains information that relates to protein\nidentification.</details>\n\n::: {.callout-answer collapse=true}\n\n**Task 1**\n\nThere are many ways to extract the number of peptides from our datasets. The\ncurrent data level shows the total number of PSMs (peptide spectrum matches).\nAlthough PSMs are fragments of identified peptide sequences, there can be many\nPSMs per unique peptide. The `rowData` is where we have stored information relating\nto our samples that are not quantitation data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                           \"Tags\"                             \n [3] \"Confidence\"                        \"Identifying.Node.Type\"            \n [5] \"Identifying.Node\"                  \"Search.ID\"                        \n [7] \"Identifying.Node.No\"               \"PSM.Ambiguity\"                    \n [9] \"Sequence\"                          \"Annotated.Sequence\"               \n[11] \"Modifications\"                     \"Number.of.Proteins\"               \n[13] \"Master.Protein.Accessions\"         \"Master.Protein.Descriptions\"      \n[15] \"Protein.Accessions\"                \"Protein.Descriptions\"             \n[17] \"Number.of.Missed.Cleavages\"        \"Charge\"                           \n[19] \"Original.Precursor.Charge\"         \"Delta.Score\"                      \n[21] \"Delta.Cn\"                          \"Rank\"                             \n[23] \"Search.Engine.Rank\"                \"Concatenated.Rank\"                \n[25] \"mz.in.Da\"                          \"MHplus.in.Da\"                     \n[27] \"Theo.MHplus.in.Da\"                 \"Delta.M.in.ppm\"                   \n[29] \"Delta.mz.in.Da\"                    \"Ions.Matched\"                     \n[31] \"Matched.Ions\"                      \"Total.Ions\"                       \n[33] \"Intensity\"                         \"Activation.Type\"                  \n[35] \"NCE.in.Percent\"                    \"MS.Order\"                         \n[37] \"Isolation.Interference.in.Percent\" \"SPS.Mass.Matches.in.Percent\"      \n[39] \"Average.Reporter.SN\"               \"Ion.Inject.Time.in.ms\"            \n[41] \"RT.in.min\"                         \"First.Scan\"                       \n[43] \"Last.Scan\"                         \"Master.Scans\"                     \n[45] \"Spectrum.File\"                     \"File.ID\"                          \n[47] \"Quan.Info\"                         \"Peptides.Matched\"                 \n[49] \"XCorr\"                             \"Number.of.Protein.Groups\"         \n[51] \"Contaminant\"                       \"Percolator.q.Value\"               \n[53] \"Percolator.PEP\"                    \"Percolator.SVMScore\"              \n```\n:::\n:::\n\n\nWe can extract the `rowdata` and store it in a new object,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrd <- cc_qf[[\"psms_raw\"]] %>% \n  rowData()\n\nrd %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 54 columns\n      Checked      Tags  Confidence Identifying.Node.Type Identifying.Node\n  <character> <logical> <character>           <character>      <character>\n1       False        NA        High            Sequest HT    Sequest HT...\n2       False        NA        High            Sequest HT    Sequest HT...\n3       False        NA        High            Sequest HT    Sequest HT...\n4       False        NA        High            Sequest HT    Sequest HT...\n5       False        NA        High            Sequest HT    Sequest HT...\n6       False        NA        High            Sequest HT    Sequest HT...\n    Search.ID Identifying.Node.No PSM.Ambiguity      Sequence\n  <character>           <integer>   <character>   <character>\n1           A                   2 Unambiguou...        REEEMR\n2           A                   2 Unambiguou...     QQNGTASSR\n3           A                   2 Unambiguou...      CHMEENQR\n4           A                   2 Unambiguou...        QACQER\n5           A                   2 Unambiguou...     HSEAATAQR\n6           A                   2 Unambiguou... QQQQQQQHQQ...\n  Annotated.Sequence Modifications Number.of.Proteins Master.Protein.Accessions\n         <character>   <character>          <integer>               <character>\n1             rEEEmR N-Term(TMT...                  2             P49755; Q1...\n2          qQnGTASSR N-Term(TMT...                  1                    Q92917\n3           cHmEENQR N-Term(TMT...                  1                    Q96TC7\n4             qAcQER N-Term(TMT...                  1                    P26358\n5          hSEAATAQR N-Term(TMT...                  1                    Q14103\n6      qQQQQQQHQQ... N-Term(TMT...                  1                    Q6Y7W6\n  Master.Protein.Descriptions Protein.Accessions Protein.Descriptions\n                  <character>        <character>          <character>\n1               Transmembr...      P49755; Q1...        Transmembr...\n2               G-patch do...             Q92917        G-patch do...\n3               Regulator ...             Q96TC7        Regulator ...\n4               DNA (cytos...             P26358        DNA (cytos...\n5               Heterogene...             Q14103        Heterogene...\n6               GRB10-inte...             Q6Y7W6        GRB10-inte...\n  Number.of.Missed.Cleavages    Charge Original.Precursor.Charge Delta.Score\n                   <integer> <integer>                 <integer>   <numeric>\n1                          1         2                         2      0.1696\n2                          0         2                         2      0.1154\n3                          0         3                         3      1.0000\n4                          0         2                         2      0.2849\n5                          0         2                         2      0.4780\n6                          0         3                         3      0.4098\n   Delta.Cn      Rank Search.Engine.Rank Concatenated.Rank  mz.in.Da\n  <numeric> <integer>          <integer>         <integer> <numeric>\n1         0         1                  1                 3   547.776\n2         0         1                  1                 1   589.802\n3         0         1                  1                 1   450.202\n4         0         1                  1                 1   510.758\n5         0         1                  1                 1   600.320\n6         0         1                  1                 1   635.659\n  MHplus.in.Da Theo.MHplus.in.Da Delta.M.in.ppm Delta.mz.in.Da Ions.Matched\n     <numeric>         <numeric>      <numeric>      <numeric>  <character>\n1      1094.55           1094.55          -0.99       -0.00054          0/0\n2      1178.60           1178.60           0.06        0.00003          0/0\n3      1348.59           1348.59          -1.08       -0.00049          0/0\n4      1020.51           1020.51          -1.44       -0.00074          0/0\n5      1199.63           1199.63          -0.33       -0.00020          0/0\n6      1904.96           1904.96          -1.33       -0.00084          0/0\n  Matched.Ions Total.Ions Intensity Activation.Type NCE.in.Percent    MS.Order\n     <integer>  <integer> <numeric>     <character>      <numeric> <character>\n1            0          0  505446.3             CID             NA         MS2\n2            0          0  197059.8             CID             NA         MS2\n3            0          0   76685.6             CID             NA         MS2\n4            0          0  103765.7             CID             NA         MS2\n5            0          0  238514.8             CID             NA         MS2\n6            0          0   76203.7             CID             NA         MS2\n  Isolation.Interference.in.Percent SPS.Mass.Matches.in.Percent\n                          <numeric>                   <integer>\n1                           0.00000                          50\n2                          47.04837                          50\n3                          30.96584                          50\n4                           3.10827                          60\n5                          12.56510                          70\n6                           0.00000                          80\n  Average.Reporter.SN Ion.Inject.Time.in.ms RT.in.min First.Scan Last.Scan\n            <numeric>             <numeric> <numeric>  <integer> <integer>\n1                30.8                    60   39.4997       5816      5816\n2                28.7                    60   39.8252       5902      5902\n3                 3.5                    60   40.0773       5967      5967\n4                 0.9                    60   40.3077       6035      6035\n5                 2.8                    60   40.7688       6151      6151\n6                 0.4                    60   40.8788       6183      6183\n  Master.Scans Spectrum.File     File.ID Quan.Info Peptides.Matched     XCorr\n     <integer>   <character> <character> <logical>        <integer> <numeric>\n1         5810 NocArrest_...        F1.1        NA              104      1.71\n2         5898 NocArrest_...        F1.1        NA              125      1.82\n3         5961 NocArrest_...        F1.1        NA                4      0.94\n4         6031 NocArrest_...        F1.1        NA              105      1.86\n5         6147 NocArrest_...        F1.1        NA              136      1.82\n6         6177 NocArrest_...        F1.1        NA              285      1.22\n  Number.of.Protein.Groups Contaminant Percolator.q.Value Percolator.PEP\n                 <integer> <character>          <numeric>      <numeric>\n1                        2       False          0.0033430       0.030030\n2                        1       False          0.0009278       0.006729\n3                        1       False          0.0014400       0.012330\n4                        1       False          0.0009278       0.006435\n5                        1       False          0.0004399       0.002259\n6                        1       False          0.0006928       0.003668\n  Percolator.SVMScore\n            <numeric>\n1               0.132\n2               0.352\n3               0.260\n4               0.360\n5               0.536\n6               0.453\n```\n:::\n:::\n\n\nIn the `rowData` we have information relating the PSM to the peptide sequence\nfrom which is is derived. This information is found in the `Sequence`. Note,\nthere is also a column called `Annotated.Sequence`. \n\nQ. What is the difference between `Sequence` and `Annotated.Sequence`?\n\nIn the following code chunk we first convert the `rowData` which is `DFrame` to\neither a `data.frame` or `tibble`. We could use the `as.data.frame` or\n`as_tibble` functions, respectively, to allow us to use pipes. We then extract\nthe column `Sequence` and use the `unique`\nfunction to group together PSMs from the same peptide. Finally, we use the\n`length` command to count the number of peptides.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Using tidyr\nrd %>%\n  as_tibble() %>%\n  pull(Sequence) %>%\n  unique() %>%\n  length() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26738\n```\n:::\n:::\n\n\nAlternative solution (among many others)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Without pipes\ntbl <- table(rd$Sequence) \nlength(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26738\n```\n:::\n:::\n\n\nWe have 26738 peptides.\n\n----\n\n**Task 2**\n\nInformation regarding the proteins is found in the `Master.Protein.Accessions` column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Using tidyr\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(Master.Protein.Accessions) %>%\n  unique() %>%\n  length() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5267\n```\n:::\n:::\n\n\nAlternative solution (among many others)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Without pipes\ntbl <- table(rd$Master.Protein.Accessions) \nlength(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5267\n```\n:::\n:::\n\n\nWe have 5267 proteins.\n\n----\n\n:::\n:::\n\n\n:::{.callout-exercise}\n#### Challenge 3: Miscleavages\n\n{{< level 2 >}}\n\n\n\nWork out what the threshold for trypsin miscleavages was during the identification search.\n\n::: {.callout-answer collapse=true}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(Number.of.Missed.Cleavages) %>%\n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n    0     1     2 \n34988  9709  1106 \n```\n:::\n:::\n\n\nWe see that during the identification search missed cleavages were limited to a\nmaximum of 2 missed cleavage sites. This is typical in bottom-up proteomics.\n\n:::\n:::\n\n\n::: {.callout-tip}\n#### Key Points\n\n- The `QFeatures` infrastructure provides a convenient and transparent way to store proteomics data across multiple levels.\n- A `QFeatures` object stores each data level as a `SummarizedExperiment`, also called an `assay`, with explicit links maintained between features across different `assay`s (e.g., links between all PSMs contributing to a peptide).\n- Explicit links between `assay`s are (i) generated automatically when aggregating data using `aggregateFeatures` or (ii) added manually using the `addAssayLinks` function, as we will see later on.\n- Within each `SummarizedExperiment` the feature data is stored within the `rowData`, quantitative data in the `assay`, and sample metadata in the `colData`. These slots are accessible using their corresponding functions.\n:::\n\n## References {-}",
    "supporting": [
      "02_import_and_infrastructure_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}