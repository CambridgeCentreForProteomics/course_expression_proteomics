{
  "hash": "33d722010056bd3d15863b7559510d07",
  "result": {
    "markdown": "---\ntitle: Exploration and visualisation of protein data\nbibliography: course_refs.bib\neditor_options: \n  chunk_output_type: console\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Know how to determine the number of PSMs, peptides, proteins and protein groups (i.e., master proteins) in an experimental assay of a `QFeatures` object\n* Understand what the `.n` column corresponds to when using the `aggregateFeatures` function to aggregate features\n* Be able to use the `subsetByFeature` function to get data across all levels for a feature of interest\n* Appreciate the use of Principal Component Analysis (PCA) for visualising key factors that contribute to sample variation \n* Complete PCA using the `prcomp` function from the `stats` package\n\n:::\n\n\n\n\n\n\n\nBefore we carry out statistical analysis to determine which of our proteins \nshow significantly differential abundance across conditions (cell cycle stages),\nwe first want to do some exploration of the protein level data. This includes\ndetermining some information that may be required for reporting and publication\npurposes as well as information corresponding to quality control.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/flow_chart/flow_chart.009.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## Determining the dimensions of our final protein data\n\nGiven that we started from the PSM level and did extensive data cleaning, \nfiltering and management of missing data, it would be useful to know how much \ndata we have left. We may want to know how many PSMs, peptides and proteins\nthe `log_norm_proteins` assay contains, given that this is the data to which\nstatistical analysis will be applied.\n\nWe can easily find the number master proteins by printing our `QFeatures` object\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 6 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25687 rows and 10 columns \n [3] log_psms: SummarizedExperiment with 25687 rows and 10 columns \n [4] log_peptides: SummarizedExperiment with 17231 rows and 10 columns \n [5] log_proteins: SummarizedExperiment with 3823 rows and 10 columns \n [6] log_norm_proteins: SummarizedExperiment with 3823 rows and 10 columns \n```\n:::\n:::\n\n\nWe can see we have 3823 master proteins, each\nrepresenting a protein group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3823\n```\n:::\n:::\n\n\n\n:::{.callout-exercise}\n#### Challenge 1: Final PSM, peptide and protein count\n\n{{< level 2 >}}\n\n\n\nDetermine how many PSMs, peptides and proteins were lost during processing of\nthe raw data to our final protein list?\n\n::: {.callout-answer collapse=true}\n\nWe started with,\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsm_count <- cc_qf[[\"psms_raw\"]] %>% nrow()\n\npeptide_count <- \n  cc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(Sequence) %>%\n  unique() %>%\n  length() \n\nprot_count <- \n  cc_qf[[\"psms_raw\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(Master.Protein.Accessions) %>%\n  unique() %>%\n  length() \n\nmessage(psm_count, \" PSMs, \", \n        peptide_count, \" peptides and \", \n        prot_count, \" protein groups\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n45803 PSMs, 26738 peptides and 5267 protein groups\n```\n:::\n:::\n\n\nAfter filtering we have,\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsm_final <- cc_qf[[\"psms_filtered\"]] %>% nrow()\n\npeptide_final <- cc_qf[[\"log_peptides\"]] %>% nrow()\n\nprot_final <- cc_qf[[\"log_norm_proteins\"]] %>% nrow()\n\nmessage(psm_final, \" PSMs, \", \n        peptide_final, \" peptides and \", \n        prot_final, \" protein groups\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n25687 PSMs, 17231 peptides and 3823 protein groups\n```\n:::\n:::\n\n\nDuring the course of data processing we have lost,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage(psm_count - psm_final, \" PSMs, \", \n        peptide_count - peptide_final, \" peptides and \", \n        prot_count - prot_final, \" protein groups\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n20116 PSMs, 9507 peptides and 1444 protein groups\n```\n:::\n:::\n\n\n:::\n:::\n\n## The `.n` column created by `aggregateFeatures`\n\nIf we look at the names of the columns within our, \"`log_peptides\"`,\n`\"log_proteins\"`  assays we see that there is a column called `.n`. This column\nwas not present in the PSM level experimental assays.\n\nFor example,\n\n::: {.cell}\n\n```{.r .cell-code}\n## Check columns in the log normalised peptide assay\ncc_qf[[\"log_peptides\"]] %>%\n  rowData() %>%\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                     \"Tags\"                       \n [3] \"Confidence\"                  \"Identifying.Node.Type\"      \n [5] \"Identifying.Node\"            \"Search.ID\"                  \n [7] \"Identifying.Node.No\"         \"PSM.Ambiguity\"              \n [9] \"Sequence\"                    \"Number.of.Proteins\"         \n[11] \"Master.Protein.Accessions\"   \"Master.Protein.Descriptions\"\n[13] \"Protein.Accessions\"          \"Protein.Descriptions\"       \n[15] \"Number.of.Missed.Cleavages\"  \"Delta.Cn\"                   \n[17] \"Rank\"                        \"Search.Engine.Rank\"         \n[19] \"Ions.Matched\"                \"Matched.Ions\"               \n[21] \"Total.Ions\"                  \"Quan.Info\"                  \n[23] \"Number.of.Protein.Groups\"    \"Contaminant\"                \n[25] \"Protein.FDR.Confidence\"      \".n\"                         \n```\n:::\n:::\n\n\nThe `.n` column is created during the aggregation process that is completed via\nthe `aggregateFeatures` function. This column stores information about how many\nchild features (PSMs/peptides) were aggregated into each parent\n(peptides/protein) feature. Since we aggregated completed two steps of\naggregation (1) PSMs to peptides, (2) peptides to proteins, the `.n` column\ntells us how many PSMs we have in support of each peptide, and how many peptides\nwe have in support of each protein, respectively.\n\nLet's examine peptide support,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>%\n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n1228  710  449  313  232  162  149  110   67   54   58   53   33   26   20   25 \n  17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 \n  19   12    8   14    9    8    7    5    6    2    1    2    1    3    1    1 \n  33   34   35   36   40   41   44   45   48   49   52   54   59   60   69   86 \n   5    3    2    4    2    2    1    2    1    1    1    3    1    1    1    1 \n  87   90  173  223 \n   1    1    1    1 \n```\n:::\n:::\n\n\n\n\nThe output tells us that we have 1228 proteins with 1 \npeptides, 710 proteins with support from 2 peptides, and so forth.\n\n:::{.callout-exercise}\n#### Challenge 2: Examining peptide support\n\n{{< level 2 >}}\n\n\n\n1. Using the information we have in the `.n` column create a graph to visualise\npeptide support. \n\n<details><summary>Inspiration</summary> The [\"from Data to Viz project\"](https://www.data-to-viz.com)\nprovides some great ideas for visualisation in R and a brilliant platform for \nexploring your data. The [R Graph Gallery](https://r-graph-gallery.com/ggplot2-package.html)\nis another great source of inspiration with coded examples to follow.</details>\n\n2. What is,\n\n(i) the *maximum* number of peptides we have available for one given protein? \n(ii) the *most common* number of peptides available for any given protein?\n(iii) the *median* number of peptides available for any given protein?\n\n<details><summary>Hint</summary> The functions `table` and `summary`\nmay help. </details>\n\n\n::: {.callout-answer collapse=true}\n\n**Task 1: Graph to visualise peptide support**\n\nThere are many ways we can visualise peptide support. The first thing we could do\nis plot a histogram. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  ggplot(aes(x = .n)) +\n  geom_histogram(binwidth = 1)\n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nIs this a good visualisation for our dataset? It is perhaps not the easiest plot\nto read if the aim is to get an overview of how many peptides are available per\nprotein group.\n\nLet's bin peptides with > 8 peptides per protein group into one category and\nthen plot the data.\n\nIn the next code chunk we create a new `tibble` which tells us how many\nproteins we have which have `n` number of peptides.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Summarise the number of peptides per protein if we have greater than 8  \npeptide_df <- cc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  select(.n) %>% \n  mutate(peptide_n = ifelse(.n <= 7, .n, \"8+\")) %>% \n  count(peptide_n) \n\npeptide_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 Ã— 2\n  peptide_n     n\n  <chr>     <int>\n1 1          1228\n2 2           710\n3 3           449\n4 4           313\n5 5           232\n6 6           162\n7 7           149\n8 8+          580\n```\n:::\n:::\n\n\nNow let's plot this data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Plot the data using a lollipop\nggplot(peptide_df, aes(x = peptide_n, y = n)) +\n  geom_segment(aes(x = peptide_n, xend = peptide_n, y=0, yend = n)) +\n  geom_point(color = \"red\", size = 4) +\n  ylab(\"Frequency\") +\n  xlab(\"Number of peptides per protein group\") +\n  theme_light() \n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nWe can also plot as a percentage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Plot the data using a lollipop\npeptide_df %>% \n  mutate(n, n_percent = n/sum(n)*100) %>% \n  ggplot(aes(x = peptide_n, y = n_percent)) +\n  geom_segment(aes(x = peptide_n, xend = peptide_n, y = 0, yend = n_percent)) +\n  geom_point(color=\"red\", size=4) +\n  ylab(\"Frequency (%)\") +\n  xlab(\"Number of peptides per protein group\") +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n**Task 2: Peptides support, summary statistics**\n\nLet's again pull the column `.n` and tabulate the output\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>% \n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n1228  710  449  313  232  162  149  110   67   54   58   53   33   26   20   25 \n  17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 \n  19   12    8   14    9    8    7    5    6    2    1    2    1    3    1    1 \n  33   34   35   36   40   41   44   45   48   49   52   54   59   60   69   86 \n   5    3    2    4    2    2    1    2    1    1    1    3    1    1    1    1 \n  87   90  173  223 \n   1    1    1    1 \n```\n:::\n:::\n\n\nLet's now calculate summary statistics to find the median number of peptides,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>% \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   1.000   2.000   4.507   5.000 223.000 \n```\n:::\n:::\n\n\n(i) We have one instance which has 223 peptides for one given protein.\n(ii) From the above output we see the most common number of peptides available to support\na given protein is 1. Single peptide hits most frequently occur in the data. \n(iii) The median number of peptides is 2.\n\n:::\n:::\n\n\n## The `subsetByFeature` function\n\nAs well as determining the dimensions of our entire dataset, both in its raw\nstate and its final state, sometimes we may wish to find out information about \na specific feature e.g., a protein of interest. The `QFeatures` infrastructure\nprovides a convenient function called `subsetByFeature` to extract all data \nlevels corresponding to a particular feature.\n\nThe `subsetByFeature` function take a `QFeatures` object as its input and an \nadditional argument specifying one or more features of interest. The output is\na new `QFeatures` object with only data corresponding to the specified features.\n\nLet's take a look at O43583, the human density-regulated protein.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nO43583 <- subsetByFeature(cc_qf, \"O43583\")\n\nexperiments(O43583)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExperimentList class object of length 6:\n [1] psms_raw: SummarizedExperiment with 5 rows and 10 columns\n [2] psms_filtered: SummarizedExperiment with 5 rows and 10 columns\n [3] log_psms: SummarizedExperiment with 5 rows and 10 columns\n [4] log_peptides: SummarizedExperiment with 4 rows and 10 columns\n [5] log_proteins: SummarizedExperiment with 1 rows and 10 columns\n [6] log_norm_proteins: SummarizedExperiment with 1 rows and 10 columns\n```\n:::\n:::\n\n\nFrom this we can see that the O43583 protein is supported by 4 peptides derived\nfrom 5 PSMs.\n\nWe can use our new `QFeatures` object to create a plot which displays how the\nPSM data was aggregated to protein for this particular feature. To do so, we\nextract the assays of interest from our `\"O43583\"` `QFeatures` object and pass\nto the `longFormat` function which will covert the subset `QFeatures` object\nto a long format `DataFrame`. We can then use the standard `ggplot2` functions\nto visualise the processing of this protein.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nO43583[, , c(\"log_psms\", \"log_peptides\", \"log_proteins\")] %>%\n  longFormat() %>%\n  as_tibble() %>%\n  mutate(assay_order = factor(assay, \n                              levels = c(\"log_psms\", \n                                         \"log_peptides\", \n                                         \"log_proteins\"))) %>%\n  ggplot(aes(x = colname, y = value, colour = assay)) + \n  geom_point() +\n  geom_line(aes(group = rowname)) +\n  theme(axis.text.x = element_text(angle = 45, size = 7)) +\n  facet_wrap(~ assay_order)\n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nOther useful functions that we do not have time to cover today include\n`subsetByAssay`, `subsetByColData`, `subsetByColumn`, `subsetByFilter`, \n`subsetByRow`, `subsetByOverlap`, and many more. To find out more about these \nfunctions you can execute a single question mark (`?`) followed by the function name. \nIf you have the `QFeatures` package installed you should be able to access a help\nand information page for the function of interest.\n\nFor example: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n?subsetByAssay\n```\n:::\n\n\n\n## Principal Component Analysis (PCA)\n\nThe final protein level exploration that we will do is Principal Component\nAnalysis (PCA).\n\nPCA is a statistical method that can be applied to condense complex data from\nlarge data tables into a smaller set of summary indices, termed principal \ncomponents. This process of dimensionality reduction makes it easier to \nunderstand the variation observed in a dataset, both how much variation there is\nand what the primary factors driving the variation are. This is particularly \nimportant for multivariate datasets in which experimental factors can contribute\ndifferentially or cumulatively to variation in the observed data. PCA allows us\nto observe any trends, clusters and outliers within the data thereby helping to\nuncover the relationships between observations and variables.\n\n\n### The process of PCA\n\nThe process of PCA can be considered in several parts:\n\n1. Scaling and centering the data\n\nFirstly, all continuous variables are standardized into the same range so that \nthey can contribute equally to the analysis. This is done by centering each\nvariable to have a mean of 0 and scaling its standard deviation to 1.\n\n\n2. Generation of a covariance matrix\n\nAfter the data has been standardized, the next step is to calculate a covariance\nmatrix. The term covariance refers to a measure of how much two variables vary\ntogether. For example, the height and weight of a person in a population will \nbe somewhat correlated, thereby resulting in covariance within the population.\nA covariance matrix is a square matrix of dimensions *p* x *p* (where *p* is \nthe number of dimensions in the original dataset i.e., the number of variables).\nThe matrix contains an entry for every possible pair of variables and describes\nhow the variables are varying with respect to each other.\n\nOverall, the covariance matrix is essentially a table which summarises the \ncorrelation between all possible pairs of variables in the data. If the covariance\nof a pair is positive, the two variables are correlated in some direction (increase\nor decrease together). If the covariance is negative, the variables are inversely\ncorrelated with one increasing when the other decreases. If the covariance is \nnear-zero, the two variables are not expected to have any relationship.\n\n\n3. Eigendecomposition - calculating eigenvalues and eigenvectors\n\nEigendecomposition is a concept in linear algebra whereby a data matrix is \nrepresented in terms of **eigenvalues** and **eigenvectors**. In this case, the\nthe eigenvalues and eigenvectors are calculated based on the covariance matrix\nand will inform us about the magnitude and direction of our data. Each eigenvector\nrepresents a direction in the data with a corresponding eigenvalue telling us how \nmuch variation in our data occurs in that direction.\n\n* Eigenvector = informs about the direction of variation\n* Eigenvalue = informs about the magnitude of variation \n\nThe number of eigenvectors and eigenvalues will always be the same as the \nnumber of dimensions (variables) in the initial dataset. In our use-case, we \nhave 10 samples, so we will have a covariance matrix of dimensions 10 x 10, and\nthis will give rise to 10 eigenvectors and 10 associated eigenvalues.\n\n\n4. The calculation of principal components\n\nPrincipal components are calculated by multiplying the original data by a \ncorresponding eigenvector. As a result, the principal components themselves\nrepresent directionality of data. The order of the principal components is\ndetermined by the corresponding eigenvector such that the first principal \ncomponent is that which explains the most variation in the data (i.e., has the\nlargest eigenvalue).\n\nBy having the first principal components explain the largest proportion of \nvariation in the data, the dimension of the data can be reduced by focusing\non these principal components and ignoring those which explain very little in \nthe data.\n\n\n### Completing PCA with `prcomp`\n\nTo carry out PCA on our data we will use the `prcomp` function from the `stats`\npackage. We first extract the quantitative matrix (assay) corresponding to the\nlog normalised protein level data. To make this matrix compatible with `prcomp`\nwe also need to transpose the data such that the samples become rows and \nproteins become columns. This is easily achieved using the `t` function. \n\nOur protein data does not contain missing values due to the decision to impute.\nHowever, if there were any missing values in the data, these would need to be \nremoved using `filterNA` to facilitate compatibility with PCA.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprotein_pca <- cc_qf[[\"log_norm_proteins\"]] %>%\n  assay() %>%\n# filterNA() %>%\n  t() %>%\n  prcomp(scale = TRUE, center = TRUE)\n\nsummary(protein_pca)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImportance of components:\n                           PC1     PC2     PC3     PC4      PC5     PC6\nStandard deviation     36.3849 26.3397 21.5926 19.8587 17.41311 14.4076\nProportion of Variance  0.3463  0.1815  0.1220  0.1032  0.07931  0.0543\nCumulative Proportion   0.3463  0.5278  0.6497  0.7529  0.83219  0.8865\n                            PC7      PC8      PC9      PC10\nStandard deviation     12.53896 11.85288 11.67217 4.302e-14\nProportion of Variance  0.04113  0.03675  0.03564 0.000e+00\nCumulative Proportion   0.92761  0.96436  1.00000 1.000e+00\n```\n:::\n:::\n\n\n\nWe now have a simplified representation of our quantitative data in the form\nof principle components (PC). The `prcomp` function outputs a list of 5 different\ninformation sources, each of which can be accessed using the `$` sign nomenclature.\n\n1. `sdev` - holds the standard deviation values for each of the principle components\n2. `rotation` - a matrix which contains each of our proteins as a row and the corresponding PC values as columns\n3. `x` - a matrix which contains each of our samples as a row and the corresponding PC values as columns\n4. `center` - if `center = TRUE` then contains the centering values, otherwise `FALSE`\n5. `scale` - if `scale = TRUE` then contains the scaling values, otherwise `FALSE`\n\n\nTo visualise the resulting PCs and how much of the data variation they explain\nwe can plot a scree plot using the `fviz_screeplot` function. The resulting plot\ndisplays the proportion of total data variation explained by each of PC.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_screeplot(protein_pca)\n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nLooking at a scree plot can be useful when deciding which principle components\nto plot and investigate further. We now want to plot each of our samples in PCA \nspace. To do this we will use the `protein_pca$x` data. Typically a 2D PCA plot\nwill display PC1 and PC2, since these are the PCs that explain the most variation \nwithin the dataset, but it can also be useful to plot later PCs if they also \nexplain a large proportion of variation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprotein_pca$x %>%\n  as_tibble() %>%\n  ggplot(aes(x = PC1, y = PC2)) +\n  geom_point(size = 3) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nIt is generally advisable to colour each point based on all possible explanatory\nvariables that may have contributed to the observed variation. In our case we\nonly have one - the cell cycle stage. \n\n\n\n:::{.callout-exercise}\n#### Challenge 3: PCA plot\n\n{{< level 2 >}}\n\n\n\n1. Generate a PCA plot of the data and colour by condition.\n\n<details><summary>Hint</summary>To colour the points based on this condition\nwe can use the tidyverse `mutate` function to add a column defining the condition\nof each sample and then use `colour = condition` within our ggplot aesthetics.</details>\n\n2. What does this plot tell us?\n\n\n::: {.callout-answer collapse=true}\n\n**Task 1**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprotein_pca$x %>%\n  as_tibble() %>%\n  mutate(condition = cc_qf[[\"log_norm_proteins\"]]$condition) %>%\n  ggplot(aes(x = PC1, y = PC2, colour = condition)) +\n  geom_point(size = 3) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](05_protein_exploration_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n---\n\n**Task 2**\n\nThis PCA plot shows clear clustering of samples based on their condition, which\nis what we would hope to see. This indicates that the observed variation could \nindeed be explained by cell cycle stage.\n:::\n:::\n\n\n\nFor more complicated multivariate experiments all possible explanatory \nvariables should be visualised. For example, if multiple batches of samples \nhave been prepared separately or several TMTplexes were used, these factors\nshould be visualised (e.g., by colour) on the PCA plot to see whether they \nare contributing the the observed variation. If the samples do cluster based on\nunwanted factors such as batch or TMTplex, additional normalisation may be \nrequired.\n\n\n::: {.callout-tip}\n#### Key Points\n\n- The `.n` column created by `aggregateFeatures` is a useful way to trace how many child features have been aggregated into a single parent feature\n- The `subsetByFeature` function can be used to generate a `QFeatures` object with all levels of data corresponding to one or more features of interest\n- Principal Component Analysis (PCA) is a dimensionality reduction method that can be used to visualise the relationship between explanatory variables and observed data. If samples cluster together based on a particular factor, this indicates that the factor\n\n:::\n\n## References {-}\n",
    "supporting": [
      "05_protein_exploration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}