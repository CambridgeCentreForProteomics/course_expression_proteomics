{
  "hash": "5faa0415227fe37d4e19e2d939ee4256",
  "result": {
    "markdown": "---\ntitle: Exploration and visualisation of protein data\nbibliography: course_refs.bib\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Know how to determine the number of PSMs, peptides, proteins and protein groups (i.e., master proteins) in an assay of a `QFeatures` object\n* Understand what the `.n` column corresponds to when using the `aggregateFeatures` function to aggregate features\n* Be able to use the `subsetByFeature` function to get data across all levels for a feature of interest\n* Appreciate the use of Principal Component Analysis (PCA) for visualising key factors that contribute to sample variation \n* Complete PCA using the `prcomp` function from the `stats` package\n\n:::\n\n\n\n\n\n\n\nBefore we carry out statistical analysis to determine which of our proteins \nshow significantly differential abundance across conditions (cell cycle stages),\nwe first want to do some exploration of the protein level data. This includes\ndetermining some information that may be required for reporting and publication\npurposes as well as information corresponding to quality control.\n\n\n## Determining the dimensions of our final protein data\n\nGiven that we started from the PSM level and did extensive data cleaning, \nfiltering and management of missing data, it would be useful to know how much \ndata we have left. We may want to know how many PSMs, peptides and proteins\nthe `log_norm_proteins` assay contains, given that this is the data to which\nstatistical analysis will be applied.\n\nWe can easily find the number of master proteins in the assay by looking at the \nnumber of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 6 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25787 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 25787 rows and 10 columns \n [4] log_imputed_psms: SummarizedExperiment with 25787 rows and 10 columns \n [5] log_proteins: SummarizedExperiment with 3912 rows and 10 columns \n [6] log_norm_proteins: SummarizedExperiment with 3912 rows and 10 columns \n```\n:::\n:::\n\n\nWe have 3912 master proteins, each representing\na protein group.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprotein_groups <- cc_qf[[\"log_norm_proteins\"]] %>%\n  nrow()\n```\n:::\n\n\n\n### The `.n` column created by `aggregateFeatures`\n\nIf we look at the names of the columns within our `\"log_proteins\"` and \n`\"log_norm_proteins\"` assays we see that there is a column called `.n`. This \ncolumn was not present in the `\"log_imputed_psms\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Check columns in the log normalised protein assay\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Checked\"                     \"Tags\"                       \n [3] \"Confidence\"                  \"Identifying.Node.Type\"      \n [5] \"Identifying.Node\"            \"Search.ID\"                  \n [7] \"Identifying.Node.No\"         \"PSM.Ambiguity\"              \n [9] \"Master.Protein.Accessions\"   \"Master.Protein.Descriptions\"\n[11] \"Delta.Cn\"                    \"Rank\"                       \n[13] \"Search.Engine.Rank\"          \"Ions.Matched\"               \n[15] \"Matched.Ions\"                \"Total.Ions\"                 \n[17] \"Quan.Info\"                   \"Number.of.Protein.Groups\"   \n[19] \"Contaminant\"                 \".n\"                         \n```\n:::\n:::\n\n\nThis column is created during the aggregation process that is completed via the\n`aggregateFeatures` function. This column stores information about how many \nchild features were aggregated into each parent feature. Since we aggregated\ndirectly from the PSMs to protein, the `.n` column tells us how many PSMs we \nhave in support of each protein in the final dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>%\n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n1192  662  415  277  222  165  114  110   83   79   58   45   57   39   36   27 \n  17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 \n  31   28   16   20   16   20   20    8   12    9    9    9   11   11    9    7 \n  33   34   35   36   37   38   39   40   41   42   43   44   46   47   48   50 \n   4    7    5    3    1    3    2    2    2    1    2    3    1    2    3    2 \n  51   52   54   56   58   59   60   62   63   65   70   72   73   74   77   81 \n   4    3    3    1    2    1    2    1    3    2    1    2    1    1    1    1 \n  82   83   87   89   91   93   94  100  111  113  118  121  124  158  185  189 \n   1    1    1    1    2    2    1    1    1    1    1    1    1    1    1    1 \n 192  224  243  267  413 \n   1    1    1    1    1 \n```\n:::\n:::\n\n\nFrom this information we can derive the average PSM support per protein or plot\na histogram to visualise the distribution of PSM support.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  ggplot(aes(x = .n)) +\n  geom_histogram(binwidth = 1)\n```\n\n::: {.cell-output-display}\n![](04_protein_exploration_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nWe can also calculate the sum of all values in the `.n` column to find out how\nmany PSMs contribute to our protein level data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsms <- cc_qf[[\"log_norm_proteins\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>%\n  sum()\n```\n:::\n\n\n\n**Challenge**\nNow we know how many master proteins are in our final dataset and how many PSMs\nsupport the quantification of these proteins. Determine how many peptide \nsequences are in support of the final master proteins.\n\n1. Use the `aggregateFeatures` function to aggregate from log imputed PSM level to log peptide and then log peptide to log protein\n2. Calculate the sum of the `.n` column in the log peptide and log protein assays - think about what these values mean in each instance\n\n**Below is the solution - change to eval=TRUE, include=FALSE**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Aggregate from PSM to peptide\ncc_qf <- aggregateFeatures(cc_qf, \n                           i = \"log_imputed_psms\", \n                           fcol = \"Sequence\",\n                           name = \"log_peptides\",\n                           fun = MsCoreUtils::robustSummary,\n                           na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nYour row data contain missing values. Please read the relevant\nsection(s) in the aggregateFeatures manual page regarding the effects\nof missing values on data aggregation.\n```\n:::\n\n```{.r .cell-code}\n## Aggregate from peptide to protein\ncc_qf <- aggregateFeatures(cc_qf, \n                           i = \"log_peptides\", \n                           fcol = \"Master.Protein.Accessions\",\n                           name = \"log_proteins_2\",\n                           fun = MsCoreUtils::robustSummary,\n                           na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nYour row data contain missing values. Please read the relevant\nsection(s) in the aggregateFeatures manual page regarding the effects\nof missing values on data aggregation.\n```\n:::\n\n```{.r .cell-code}\n## Sum of .n in peptide-level (i.e., total PSMs)\ncc_qf[[\"log_peptides\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>%\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25787\n```\n:::\n\n```{.r .cell-code}\n## Sum of .n in protein level (i.e., total peptides)\ncc_qf[[\"log_proteins_2\"]] %>%\n  rowData() %>%\n  as_tibble() %>%\n  pull(.n) %>%\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17323\n```\n:::\n:::\n\n\n\n**Challenge** \nSometimes we also want to know the dimensions of the raw data. For example, if \nwe want to report how many PSMs or peptides were in support of a protein's\n*identification* rather than its *quantitation* then using the raw data is \nmore appropriate. \n\nLook at the names of the `rowData` colums in the `\"psms_raw\"` assay. Determine\nhow many PSMs, unique peptide sequences (i.e., sequences regardless of modification)\nand master protein accessions were identified from the raw data.\n\n**Below is the solution! need to hide**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45803\n```\n:::\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  rowData() %>%\n  as_tibble() %>%\n  pull(Sequence) %>%\n  unique() %>%\n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26738\n```\n:::\n\n```{.r .cell-code}\ncc_qf[[\"psms_raw\"]] %>% \n  rowData() %>%\n  as_tibble() %>%\n  pull(Master.Protein.Accessions) %>%\n  unique() %>%\n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5267\n```\n:::\n:::\n\n\n\n## Extracting information about a specific feature using `subsetByFeature`\n\nAs well as determining the dimensions of our entire dataset, both in its raw\nstate and its final state, sometimes we may wish to find out information about \na specific feature e.g., a protein of interest. The `QFeatures` infrastructure\nprovides a convenient function called `subsetByFeature` to extract all data \nlevels corresponding to a particular feature.\n\nThe `subsetByFeature` function take a `QFeatures` object as its input and an \nadditional argument specifying one or more features of interest. The output is\nthen a new `QFeatures` object with only data corresponding to the specified \nfeatures.\n\nLet's take a look at O43583\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsetByFeature(cc_qf, \"O43583\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 8 assays:\n [1] psms_raw: SummarizedExperiment with 0 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 5 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 5 rows and 10 columns \n ...\n [6] log_norm_proteins: SummarizedExperiment with 1 rows and 10 columns \n [7] log_peptides: SummarizedExperiment with 4 rows and 10 columns \n [8] log_proteins_2: SummarizedExperiment with 1 rows and 10 columns \n```\n:::\n:::\n\n\n\n\n## Principal Component Analysis (PCA)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprotein_pca <- cc_qf[[\"log_norm_proteins\"]] %>%\n  assay() %>%\n  t() %>%\n  prcomp(scale = TRUE, center = TRUE)\n\nsummary(protein_pca)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImportance of components:\n                          PC1     PC2     PC3     PC4      PC5      PC6\nStandard deviation     36.789 26.4354 22.0562 20.2794 17.67664 14.44580\nProportion of Variance  0.346  0.1786  0.1244  0.1051  0.07987  0.05334\nCumulative Proportion   0.346  0.5246  0.6490  0.7541  0.83396  0.88730\n                            PC7      PC8    PC9      PC10\nStandard deviation     12.75040 11.88987 11.702 3.978e-14\nProportion of Variance  0.04156  0.03614  0.035 0.000e+00\nCumulative Proportion   0.92886  0.96500  1.000 1.000e+00\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprotein_pca$x %>%\n  as_tibble() %>%\n  mutate(condition = cc_qf[[\"log_norm_proteins\"]]$condition) %>%\n  ggplot(aes(x = PC1, y = PC2, colour = condition)) +\n  geom_point(size = 3) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](04_protein_exploration_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-tip}\n#### Key Points\n\n- The `.n` column created by `aggregateFeatures` is a useful way to trace how many child features have been aggregated into a single parent feature\n- The `subsetByFeature` function \n\n:::\n\n## References {-}",
    "supporting": [
      "04_protein_exploration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}