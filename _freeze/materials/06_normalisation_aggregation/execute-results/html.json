{
  "hash": "c38e87b3fb1e29bd8503a395757aad24",
  "result": {
    "markdown": "---\ntitle: Data normalisation and data aggregation\nbibliography: course_refs.bib\neditor_options: \n  chunk_output_type: console\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Be able to aggregate peptide-level information to protein-level using the `aggregateFeatures` function in the `QFeatures` infrastructure\n* Recognise the importance of log transformation (`logTransform`) \n* Know how to normalise your data (using `normalize`) and explore the most appropriate methods for expression proteomics data \n:::\n\n\n\n\n\n\n\nLet's start by recapping which stage we have reached in the processing of our \nquantitative proteomics data. In the previous two lessons we have so far learnt,\n\n* how to import our data into R and store it in a `QFeatures` object\n* work with the structure of `QFeatures` objects\n* clean data using a series of non-specific and data-dependent filters\n\nIn this next lesson we will continue processing the PSM level data, explore log\ntransformation, normalisation and then aggregate our data to protein-level\nintensities.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/flow_chart/flow_chart.006.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## Logarithmic transformation\n\nLet's recap our data,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 3 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n```\n:::\n:::\n\n\nNow that we are satisfied with our PSM quality, we need to log2 transform the\nquantitative data. If we take a look at our current (raw) quantitative data we will \nsee that our abundance values are dramatically skewed towards zero.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Look at distribution of abundance values in untransformed data\ncc_qf[[\"psms_imputed\"]] %>%\n  assay() %>%\n  longFormat() %>%\n  ggplot(aes(x = value)) +\n  geom_histogram() + \n  theme_bw() +\n  xlab(\"Abundance (raw)\")\n```\n\n::: {.cell-output-display}\n![](06_normalisation_aggregation_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\nThis is to be expected since the majority of proteins exist at low abundances\nwithin the cell and only a few proteins are highly abundant. However, if we \nleave the quantitative data in a non-Gaussian distribution then we will not be\nable to apply parametric statistical tests later on. Consider the case where\nwe have a protein with abundance values across three samples A, B and C. If the\nabundance values were 0.1, 1 and 10, we can tell from just looking at the numbers\nthat the protein is 10-fold more abundant in sample B compared to sample A, and\n10-fold more abundant in sample C than sample B. However, even though the fold-\nchanges are equal, the abundance values in A and B are much closer together on \na linear scale than those of B and C. A parametric test would not account for \nthis bias and would not consider A and B to be as equally different as B and C.\nBy applying a logarithmic transformation we can convert our skewed asymmetrical \ndata distribution into a symmetrical, Gaussian distribution, as visualised below. \n\n::: {.callout-note}\n#### Why use base-2 logarithmic transformation?\nAlthough there is no mathematical reason for applying a log2 transformation \nrather than using a higher base such as log10, the log2 scale provides an easy\nvisualisation tool. Any protein that halves in abundance between conditions will\nhave a 0.5 fold change, which translates into a log2 fold change of -1. Any protein\nthat doubles in abundance will have a fold change of 2 and a log2 fold change of\n+1. \n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Look at distribution of abundance values in untransformed data\ncc_qf[[\"psms_imputed\"]] %>%\n  assay() %>%\n  longFormat() %>%\n  ggplot(aes(x = log2(value))) +\n  geom_histogram() + \n  theme_bw() +\n  xlab(\"(Log2) Abundance\")\n```\n\n::: {.cell-output-display}\n![](06_normalisation_aggregation_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nTo apply this log2 transformation to our data we use the `logTransform` function\nand specify `base = 2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- logTransform(object = cc_qf, \n                      base = 2, \n                      i = \"psms_imputed\", \n                      name = \"log_psms_imputed\")\n```\n:::\n\n\nLet's take a look again at our `QFeatures` object,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 4 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [4] log_psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n```\n:::\n:::\n\n\n## Aggregation of PSMs to peptides to proteins\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/flow_chart/flow_chart.007.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nWe have now reached the point where we are ready to aggregate our PSM level data\nupward to the protein level. In a bottom-up MS experiment we initially identify\nand quantify peptides. Further, each peptide can be identified and quantified on \nthe basis of multiple matched spectra (the peptide spectrum matches, PSMs). We \nnow want to group information from all PSMs that correspond to the same master\nprotein accession. \n\nTo aggregate upwards from PSM to proteins we can either do this (i) directly\n(from PSM straight to protein, if we are not interested in peptide level\ninformation) or (ii) include an intermediate step of aggregating from PSM to\npeptides, and then from the peptide level to proteins. Which you do will depend\non your biological question. For the purpose of demonstration, let's perform\nthe explicit step of PSM to peptide aggregation.\n\nIn your console run the `aggregateFeatures` function on your `QFeatures` object.\nWe wish to aggregate from PSM to peptide level so pass the argument \n`i = \"log_imputed_psms\"` to specify we wish to aggregate the log transformed PSM\ndata, and then pass `fcol = \"Sequence\"` to specify we wish to\ngroup by the peptide amino acid sequence.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- aggregateFeatures(cc_qf, \n                           i = \"log_psms_imputed\", \n                           fcol = \"Sequence\",\n                           name = \"log_peptides\",\n                           fun = MsCoreUtils::robustSummary,\n                           na.rm = TRUE)\n\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 5 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [4] log_psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [5] log_peptides: SummarizedExperiment with 17236 rows and 10 columns \n```\n:::\n:::\n\n\nWe see we have created a new assay called `log_peptides` and summarised \n25698 PSMs into 17236\npeptides.\n\nThere are many ways in which we can combine the quantitative values from each of\nthe contributing PSMs into a single consensus peptide or protein quantitation.\nSimple methods for doing this include calculating the peptide or master protein\nquantitation based on the mean, median or sum PSM quantitation. Although the use\nof these simple mathematical functions can be effective, using `colMeans` or\n`colMedians` can become difficult for data sets that still contain missing\nvalues. Similarly, using `colSums` can result in protein quantitation values\nbeing biased by the presence of missing values. Here we will use\n`robustSummary`, a state-of-the art aggregation method that is able to aggregate\neffectively even in the presence of missing values @Sticker2020.\n\nLet's complete our aggregation by now aggregating our peptide level data to \nprotein level data. Let's again use the `aggregateFeatures` function and pass\n`fcol = \"Master.Protein.Accessions\"` to specify we wish to\ngroup by `\"Master.Protein.Accessions\"`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- aggregateFeatures(cc_qf, \n                           i = \"log_peptides\", \n                           fcol = \"Master.Protein.Accessions\",\n                           name = \"log_proteins\",\n                           fun = MsCoreUtils::robustSummary,\n                           na.rm = TRUE)\n\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 6 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [4] log_psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [5] log_peptides: SummarizedExperiment with 17236 rows and 10 columns \n [6] log_proteins: SummarizedExperiment with 3825 rows and 10 columns \n```\n:::\n:::\n\n\nWe see we have now created a new assay with 3825 \nprotein groups. \n\n\n::: {.callout-note}\n#### Protein groups\nSince we are aggregating all PSMs that are assigned to the same master protein\naccession, the downstream statistical analysis will be carried out at the \nlevel of protein groups. This is important to consider since most people will \nreport \"proteins\" as displaying significantly different abundances across \nconditions, when in reality they are referring to protein groups.\n\n:::\n\n## Normalisation of quantitative data \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figs/flow_chart/flow_chart.008.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nWe now have log protein level abundance data to which we could apply a parametric\nstatistical test. However, to perform a statistical test and discover whether any \nproteins differ in abundance between conditions (here cell cycle stages), we first\nneed to account for non-biological variance that may contribute to any differential\nabundance. Such variance can arise from experimental error or technical variation,\nalthough the latter is much more prominent when dealing with label-free DDA data.\n\nNormalisation is the process by which we account for non-biological variation in\nprotein abundance between samples and attempt to return our quantitative data \nback to its 'normal' condition i.e., representative of how it was in the original\nbiological system. There are various methods that exist to normalise expression\nproteomics data and it is necessary to consider which of these to apply on a \ncase-by-case basis.\n\nUnfortunately, there is not currently a single normalization method which\nperforms best for all quantitative proteomics datasets. Within the R Bioconductor\npackages, however, exists [`NormalyzerDE`](https://bioconductor.org/packages/release/bioc/html/NormalyzerDE.html) @Willforss2018, a tool for evaluating different\nnormalisation methods.\n\n:::{.callout-exercise}\n#### Challenge 1: Using NormalyzerDE\n\n{{< level 1 >}}\n\n\n\nThe `NormalyzerDE` package provides a function called `normalyzer` which is \nuseful for getting an overview of how different normalisation methods perform\non a dataset. The `normalyzer` function however **requires a raw intensity matrix\nas input, prior to any log transformation.** \n\n1. Taking the your data from the `psms_imputed` level, create a new assay in\nyour `QFeatures` object (`cc_qf`) that aggregates the data from this level \ndirectly to protein level. Call this assay `\"proteins_direct\"`.\n\n2. Run the `normalyzer` function on the newly created (un-transformed) \nprotein level data using the below code,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalyzer(jobName = \"normalyzer\",\n           experimentObj = cc_qf[[\"proteins_direct\"]],\n           sampleColName = \"sample\",\n           groupColName = \"condition\",\n           outputDir = \".\",\n           requireReplicates = FALSE)\n```\n:::\n\n\nIf your job is successful a new folder will be created in your working directory\ncalled `normalyzer`. Take a look at the PDF report. What method do you think is\nappropriate?\n\n::: {.callout-answer collapse=true}\n\n**Task 1** Create a new protein level assay that takes the imputed PSMs and \naggregates directly to protein level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- aggregateFeatures(cc_qf,\n                           i = \"psms_imputed\", \n                           fcol = \"Master.Protein.Accessions\",\n                           name = \"proteins_direct\",\n                           fun = MsCoreUtils::robustSummary,\n                           na.rm = TRUE)\n\n## Verify\ncc_qf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn instance of class QFeatures containing 7 assays:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns \n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns \n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [4] log_psms_imputed: SummarizedExperiment with 25698 rows and 10 columns \n [5] log_peptides: SummarizedExperiment with 17236 rows and 10 columns \n [6] log_proteins: SummarizedExperiment with 3825 rows and 10 columns \n [7] proteins_direct: SummarizedExperiment with 3825 rows and 10 columns \n```\n:::\n:::\n\n\n**Task 2** Running `normalyzer` on your assay.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalyzer(jobName = \"normalyzer\",\n           experimentObj = cc_qf[[\"proteins_direct\"]],\n           sampleColName = \"sample\",\n           groupColName = \"condition\",\n           outputDir = \".\",\n           requireReplicates = FALSE)\n```\n:::\n\n\nNote: To run `normalyzer` on this data we need to pass `requireReplicates =\nFALSE` as we have only one sample of the control. For more details on using the\n`NormalyzerDE` package take a look at the [package vignette](https://bioconductor.org/packages/release/bioc/vignettes/NormalyzerDE/inst/doc/vignette.html).\n\n\n:::\n:::\n\nThe `\"center.median\"` method looks reasonable so we proceed to normalise our\ndata with this method. In `QFeatures` we can use the `normalize` function.\nTo see which other normalisation methods are supported within this function,\ntype `?normalize` to access the function's help page. Before normalising the \ndata complete the following exercise,\n\n:::{.callout-exercise}\n#### Challenge 2: Aggregating PSM straight to protein\n\n{{< level 1 >}}\n\n\n\nFor this biological question we are not interested in peptide level data and\nwish to avoid the intermediate summarisation step of aggreagting PSMs to\npeptides. Take the log PSM data and aggregate the data straight to the protein level. \n\n::: {.callout-answer collapse=true}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- aggregateFeatures(cc_qf,\n                           i = \"psms_imputed\", \n                           fcol = \"Master.Protein.Accessions\",\n                           name = \"log_proteins_direct\",\n                           fun = MsCoreUtils::robustSummary,\n                           na.rm = TRUE)\n\n## Verify\ncc_qf@ExperimentList\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExperimentList class object of length 8:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns\n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns\n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns\n [4] log_psms_imputed: SummarizedExperiment with 25698 rows and 10 columns\n [5] log_peptides: SummarizedExperiment with 17236 rows and 10 columns\n [6] log_proteins: SummarizedExperiment with 3825 rows and 10 columns\n [7] proteins_direct: SummarizedExperiment with 3825 rows and 10 columns\n [8] log_proteins_direct: SummarizedExperiment with 3825 rows and 10 columns\n```\n:::\n:::\n\n\n:::\n:::\n\n\nNow let's normalise the protein level data that has been directly aggregated\nfrom PSMs, \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- normalize(cc_qf, \n                   i = \"log_proteins\", \n                   name = \"log_norm_proteins\",\n                   method = \"center.median\")\n```\n:::\n\n\nLet's verify the normalisation  by viewing the `QFeatures` object. We can call\n`@ExperimentList` to view all the assays we have created,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf@ExperimentList\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExperimentList class object of length 9:\n [1] psms_raw: SummarizedExperiment with 45803 rows and 10 columns\n [2] psms_filtered: SummarizedExperiment with 25698 rows and 10 columns\n [3] psms_imputed: SummarizedExperiment with 25698 rows and 10 columns\n [4] log_psms_imputed: SummarizedExperiment with 25698 rows and 10 columns\n [5] log_peptides: SummarizedExperiment with 17236 rows and 10 columns\n [6] log_proteins: SummarizedExperiment with 3825 rows and 10 columns\n [7] proteins_direct: SummarizedExperiment with 3825 rows and 10 columns\n [8] log_proteins_direct: SummarizedExperiment with 3825 rows and 10 columns\n [9] log_norm_proteins: SummarizedExperiment with 3825 rows and 10 columns\n```\n:::\n:::\n\n\n\n:::{.callout-exercise}\n#### Challenge 3: Visualising the data prior and post-normalisation\n\n{{< level 3 >}}\n\n\n\nCreate two boxplots pre- and post-normalisation to visualise the effect it has\nhad on the data and add colour to distinguish between conditions.\n\n::: {.callout-answer collapse=true}\n\nUsing `ggplot2`,\n\n\n::: {.cell}\n\n```{.r .cell-code}\npre_norm <- cc_qf[[\"log_proteins\"]] %>%\n  assay() %>%\n  longFormat() %>%\n  ggplot(aes(x = colname, y = value)) +\n  geom_boxplot() +\n  labs(x = \"Sample\", y = \"log2(abundance)\", title = \"Pre-normalization\") \n\npost_norm <- cc_qf[[\"log_norm_proteins\"]] %>%\n  assay() %>%\n  longFormat() %>%\n  ggplot(aes(x = colname, y = value)) +\n  geom_boxplot() +\n  labs(x = \"Sample\", y = \"log2(abundance)\", title = \"Post-normalization\") \n\npre_norm  + post_norm \n```\n\n::: {.cell-output-display}\n![](06_normalisation_aggregation_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nColour coding by condition,\n\n\n::: {.cell}\n\n```{.r .cell-code}\npre_norm <- cc_qf[[\"log_proteins\"]] %>%\n  assay() %>%\n  longFormat() %>%\n  mutate(Condition = strsplit(colname, split = \"_\") %>% \n           sapply(\"[[\", 1)) %>%\n  ggplot(aes(x = colname, y = value, fill = Condition))  +\n  geom_boxplot() +\n  labs(x = \"Sample\", y = \"log2(abundance)\", title = \"Pre-normalization\") +\n  theme(legend.position = \"none\")\n\npost_norm <- cc_qf[[\"log_norm_proteins\"]] %>%\n  assay() %>%\n  longFormat() %>%\n  mutate(Condition = strsplit(colname, split = \"_\") %>% \n           sapply(\"[[\", 1)) %>% \n  ggplot(aes(x = colname, y = value, fill = Condition))  +\n  geom_boxplot() +\n  labs(x = \"Sample\", y = \"log2(abundance)\", title = \"Post-normalization\") \n\npre_norm + post_norm \n```\n\n::: {.cell-output-display}\n![](06_normalisation_aggregation_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n:::\n:::\n\n\n\n\n\n\n\n::: {.callout-tip}\n#### Key Points\n\n- Expression proteomics data should be log2 transformed to generate a Gaussian distribution which is suitable for parametric statistical testing. This is done using the `logTransform` function.\n- Aggregation from lower level data (e.g., PSM) to high level identification and quantification (e.g., protein) is achieved using the `aggregateFeatures` function, which also creates explicit links between the original and newly created `assays`.\n- To remove non-biological variation, data normalisation should be completed using the `normalize` function. To help users decide which normalisation method is appropriate for their data we recommend using the `normalyzer` function to create a report containing a comparison of methods.\n:::\n\n## References {-}\n",
    "supporting": [
      "06_normalisation_aggregation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}