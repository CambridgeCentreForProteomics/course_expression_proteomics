---
title: Import and infrastructure
bibliography: course_refs.bib
---

::: {.callout-tip}
#### Learning Objectives

* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related
* Know how to import data into a `QFeatures` object 
* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`

:::

## The infrastructure

MS-based quantitative proteomics data is typically represented as a matrix in 
which the rows represent features (PSMs, peptides or proteins) and the columns
contain information about these features, including their quantification 
measurements across several samples. As we saw before, this type of quantitative
proteomics matrix can be generated by using third party softwares to process
raw MS data. Moreover, the software usually outputs a quantitative matrix for 
each data level (e.g., PSM, peptide, peptide groups, protein groups).

### The structure of a `SummarizedExperiment`

A commonly used representation of these matrices in R is the `SummarizedExperiment`
structure (as shown in @fig-summarized-experiment). To simplify the
storage of such complex data, `SummarizedExperiment` objects can be conceptualised
as data containers made up of three different parts:

1. The `assay` - a matrix-like data structure which contains the quantitative
data from a proteomics experiment. Each row represents a feature (a PSM, peptide
or protein) and each column contains the quantitative data (measurements) from
one experimental sample.

2. The `rowData` - a second matrix-like data structure which contains all remaining
information derived from an identification search (i.e. every column from your
identification search output that was not a quantification column). Rows 
represent features but columns inform about different attributes of the feature
(e.g., its sequence, name, modifications).

3. The `colData` - an additional area to store sample metadata that would not
appear in the output of your identification search. This could be for example,
the cell line used, which condition, which replicate each sample corresponds to
etc. Again, this information is stored in a matrix-like data structure.

Finally, there is also the `metadata` slot which is a place for users to store
experimental metadata for example which instrument the samples were run on, the
operators name, the date the samples were run and so forth.

```{r fig-summarized-experiment, echo = FALSE, fig.cap = "Diagramatic representation of the structure of a `SummarizedExperiment` object in R", fig.align = "center", out.width = "100%"}
knitr::include_graphics("figs/summarized-experiment.png", error = FALSE)
```

Data stored in these three main areas can be easily accessed using the `assay()`, 
`rowData()` and `colData()` functions, as we will see later.


### The structure of a `QFeatures` object

Whilst a `SummarizedExperiment` is able to neatly store quantitative proteomics
data at a single data level (i.e., PSM, peptide or protein), a typical data
analysis workflow requires us to look across multiple levels. For example, it is
common to start an analysis with a lower data level and then aggregate upward
towards a final protein-level dataset. Doing this allows for greater flexibility
and understanding of the processes required to clean and aggregate the data.

A `QFeatures` object is essentially a list of `SummarizedExperiment` objects.
However, the main benefit of using a `QFeatures` object over storing each data
level as an independent `SummarizedExperiment` is that the `QFeatures` 
infrastructure maintains explicit links between the `SummarizedExperiment`s that 
it stores. This allows for maximum traceability when processing data across 
multiple levels e.g., tracking which PSMs contribute to each peptide and which 
peptides contribute to a protein (@fig-qfeatures).


```{r fig-qfeatures, echo = FALSE, fig.cap = "Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.", fig.align = "center", out.width = "100%"}
knitr::include_graphics("figs/qfeatures.png", error = FALSE)
```

**Note**
When talking about a `QFeatures` object, each dataset (individual `SummarizedExperiment`)
can be referred to as an `assay`. This is not to be confused with the quantitative
matrix section of a `SummarizedExperiment`, which is also called the `assay` data.

In order to generate the explicit links between data levels, we need to import
the lowest desired data level into a `QFeatures` object and aggregate upwards
within the `QFeatures` infrastructure using the `aggregateFeatures` function,
as we will later in this course. If two `SummarizedExperiments` are generated 
separately and then added into the same `QFeatures` object, there will not
automatically be links between them. In this case, if links are required, we
can manually add links using the `addAssayLink()` function.

The best way to get our head around the `QFeatures` infrastructure is to import
our data into a `QFeatures` object and start exploring. 

## Working with `QFeatures` in R

### Packages 

During this course we will use several R/Bioconductor packages. 

Let's begin by opening RStudio and loading these packages into our working
environment. 

```{r load_packages, message = FALSE, results = "hide", warning=FALSE}
library("QFeatures")
library("ggplot2")
library("stringr")
library("dplyr")
library("tibble")
library("NormalyzerDE")
library("corrplot")
library("Biostrings")
library("limma")
library("statmod")
library("factoextra")
library("org.Hs.eg.db")
library("clusterProfiler")
library("enrichplot")
library("patchwork")
```

### Working directory {-}

Set your working directory to xxx where you will find the `data` folder which
contains the material required for this course. This can be done by using the
`setwd` function or by going to the menu Session -> Set Working Directory ->
Choose Directory, in RStudio.

### Importing data into R

There are several ways in which data can be imported into a `QFeatures` object.
For example, it is possible to first read the data into a `SummarizedExperiment`
object using the `readSummarizedExperiment()` function, and the import this
`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can 
import our data directly into a `QFeatures` object using the `readQFeatures()`
function. We will use the latter.

Arguments to pass to `readQFeatures`:

* `table` = file path to our data
* `ecol` = an index for columns containing quantitative data. Can be a numeric 
index of the columns or a character vector containing the column names
* `sep` = the file delimiter used (`\t` for tab-delimited `.txt` files and 
`,` for comma separated `.csv` files)
* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`
within the `QFeatures` object

Let's read in the total proteome dataset from our experiment which is has been
output from Proteome Discoverer at the PSM level. The file is called
`cell_cycle_total_proteome_analysis_PSMs.txt`. We will pass it to the
`readQFeatures` function. The quantitation data is stored in columns 47 through
to 56, this is passed to the `ecol` argument. The `.txt` file is tab-delimited
so we pass `sep = "\t"`. This is the first data import before any processing so
let's call this data level `"psms_raw"`.

```{r}
## Import data into QF object
cc_qf <- readQFeatures(table = "data/cell_cycle_total_proteome_analysis_PSMs.txt",
                       ecol = 47:56, 
                       sep = "\t",
                       name = "psms_raw")
```


::: {.callout-note}
#### Finding help files
During this course we see many new functions. For more information on any R
function type `?` and the name of the function in the R console to bring up
the relavent documentation. Or go to the Help menu in RStudio and 
Help -> Search R Help. For example, to see the help files and documentation for
the `readQFeatures` function type `?readQFeatures` in your RStudio console.

:::


### Accessing information within a `QFeatures` object

Let's take a look at our newly created object.

```{r}
cc_qf
```

We see that we have created a `QFeatures` object containing a single
`SummarizedExperiment` called "psms_raw". There are `r nrow(cc_qf[["psms_raw"]])`
rows in the data, representing `r nrow(cc_qf[["psms_raw"]])` PSMs. We also see
that there are `r  ncol(cc_qf[["psms_raw"]])` columns representing our 10 samples.

We can access individual `SummarizedExperiment`s within a `QFeatures` object
using standard double bracket nomenclature (this is how you would normally
access items of a `list` in R). As with all indexing we can use the list
position or assay name.


```{r}
## Indexing using position
cc_qf[[1]]

## Indexing using name
cc_qf[["psms_raw"]]
```

Within each `SummarizedExperiment`(SE), the `rowData`, `colData` and `assay`
data are accessed using `rowData()`, `colData()` and `assay()`, respectively.
Let's use these functions to explore the data structure further.


### How has our data been organised within the `QFeatures` object? 

Let's start with the quantitation data of our SE called `psms_raw`. This is
stored in the `assay` slot.

```{r, eval=FALSE}
assay(cc_qf[["psms_raw"]])
```

You will see that the R console is populated with the quantitation data and the
whole dataset is too big to print to the screen. Let's use the `head` command to
show only the 6 lines (default) of the quantitation data.

Type into your R console,

```{r}
head(assay(cc_qf[["psms_raw"]]))
```

This is equivalent to,

```{r}
cc_qf %>% 
  assay() %>% 
  head()
```

The first code chunk uses nested functions and the second uses pipes. Throughout
this course for ease of coding and clarity we will use pipes and where 
appropriate follow the `tidyverse` style of coding for clarity. 

::: {.callout-note}
#### dplyr and tidyr
In this course we will frequently use pipes, specifically the `dplyr` pipe part
of the `dplyr` packjage and `tidyverse`. The pipe operator allows you to link
together multiple operations and code complex tasks in a more linear and
understandable way, rather than having to nest multiple function calls or write
multiple lines of code. For more information see Hadley Wickham's Tidyverse at
[https://www.tidyverse.org](https://www.tidyverse.org).

:::

:::{.callout-exercise}
#### Challenge 1: Accessing information
{{< level 1 >}}

Explore the `QFeatures` object you have just created. 

1. How many assays do we currently have in the object? 

2. How many PSMs have been quantified in the data?

3. How do access and view the quantitation data?


::: {.callout-answer collapse=true}

**Task 1**

When we type the name of the the object `cc_qf` a summary of the data is 
printed to the screen. This summary shows us a summary of the number of assays
we have in the data.

```{r}
cc_qf
```

We can check the number of `QFeatures` assays i.e. data levels by accessing
the `experimentList` slot

```{r}
cc_qf@ExperimentList
```

----

**Task 2**

Similarly, the object summary also tells us the number of PSMs. We can also
extract the number of rows (PSMs in our case) for a given level (i.e. `psms_raw`)

```{r}
cc_qf[["psms_raw"]] %>% 
  nrow()
```

----

**Task 3**

We can use the `assay` accessor,

```{r, eval=FALSE}
cc_qf[["psms_raw"]] %>% 
  assay()
```

or equivalently,

```{r, eval=FALSE}
assay(cc_qf[["psms_raw"]])
```

----

:::
:::

As expected, the `assay` slot contains 10 quantitative columns corresponding to
the 10 samples in our experiment. We see some quantitative values and some 
missing values, here denotated `NA`.

Now let's examine the the `rowData` slot,

```{r}
cc_qf[["psms_raw"]] %>%
  rowData %>%
  names()
```

The columns of our `rowData` contain non-quantitative information derived from 
the third party identification search. The exact names of variables will differ
between software and change over time, but the key information that we need to
know about each feature (here PSMs) will always be here. This information 
includes the sequence of the peptide to which each PSM corresponds (`"Sequence"`)
as well as the master protein to which the peptide is assigned (`"Master.Protein.Accessions"`).
We will come across more of the variables stored in the `rowData` when we come
to data cleaning and filtering.

We again use the `head` command to print the first 6 rows of the `rowData`

```{r, eval = FALSE}
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  head()
```


:::{.callout-exercise}
#### Challenge 2: Calculating the number of peptides and proteins in our dataset
{{< level 2 >}}

Explore the information stored in the `rowData` from the Proteome Discoverer
search. Look at the first few rows of this data matrix by using the `head`
function and find a column that related to the peptide sequence information.

1. How many peptides have been quantified in the dataset?

<details><summary>Hint 1</summary> Extract the `rowData` and convert it to a
`tibble` or `data.frame`. Find a column that contains information that relates
to the peptide sequence. The `unique` function may be helpful. </details>

2. How many proteins have been identified in the dataset? 

<details><summary>Hint</summary> Again, convert the `rowData` to a `tibble` or
`data.frame` and find a column that contains information that relates to protein
identification.</details>

::: {.callout-answer collapse=true}

**Task 1**

There are many ways to extract the number of peptides from our datasets. The
current data level shows the total number of PSMs (peptide spectrum matches).
Although PSMs are fragments of identified peptide sequences, there can be many
PSMs per unique peptide. The `rowData` is where we have stored information relating
to our samples that are not quantitation data. 

```{r}
cc_qf[["psms_raw"]] %>%
  rowData() %>% 
  names()
```

We can extract the `rowdata` and store it in a new object,

```{r}
rd <- cc_qf[["psms_raw"]] %>% 
  rowData()

rd %>% head()
```

In the `rowData` we have information relating the PSM to the peptide sequence
from which is is derived. This information is found in the `Sequence`. Note,
there is also a column called `Annotated.Sequence`. 

Q. What is the difference between `Sequence` and `Annotated.Sequence`?

In the following code chunk we first convert the `rowData` which is `DFrame` to
either a `data.frame` or `tibble`. We could use the `as.data.frame` or
`as_tibble` functions, respectively, to allow us to use pipes. We then extract
the column `Sequence` and use the `unique`
function to group together PSMs from the same peptide. Finally, we use the
`length` command to count the number of peptides.

```{r}
## Using tidyr
rd %>%
  as_tibble() %>%
  pull(Sequence) %>%
  unique() %>%
  length() 
```

Alternative solution (among many others)

```{r}
## Without pipes
tbl <- table(rd$Sequence) 
length(tbl)
```

We have `r length(tbl)` peptides.

----

**Task 2**

Information regarding the proteins is found in the `Master.Protein.Accessions` column. 

```{r}
## Using tidyr
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  as_tibble() %>%
  pull(Master.Protein.Accessions) %>%
  unique() %>%
  length() 
```

Alternative solution (among many others)

```{r}
## Without pipes
tbl <- table(rd$Master.Protein.Accessions) 
length(tbl)
```

We have `r length(tbl)` proteins.

----

:::
:::



The final slot within our `SummarizedExperiment` is the `colData`.

```{r}
cc_qf[["psms_raw"]] %>%
  colData()
```

We have a `DataFrame` structure with 10 rows, one per sample, but no columns yet. 
This is because the sample metadata is not derived from an identification 
search and does not appear in our output `.txt` file. If we want to store extra
information about our samples, we need to add this to the `colData` ourselves.

Each row of this 10 by 0 `DataFrame` corresponds to some feature of the 
quantitation channel. The names of these rows are the TMT sample names,

```{r}
cc_qf[["psms_raw"]] %>%
  colData() %>% 
  rownames()
```

### Annotating samples by adding meta-data to the `colData`

We can add columns to the `colData` using the `$` operator in the same way as 
a normal `data.frame`.  

```{r}
## Annotate colData with condition information
cc_qf$sample <- c("Control", "M_1", "M_2", "M_3",
                  "G1_1", "G1_2", "G1_3",
                  "DS_1", "DS_2", "DS_3")

## Now add replicate information
cc_qf$rep <- c(NA, rep(1:3, 3))

## And condition information
cc_qf$condition <- c("Pre-treatment", rep(c("M", "G1", "Desynch"), each = 3))

## Add the TMT information
cc_qf$tag <- colnames(cc_qf[["psms_raw"]]) %>%
  strsplit(split = "Abundance.") %>% 
  sapply("[[", 2)

## Verify
colData(cc_qf)

## Apply this to the first assay so that it is carried up
colData(cc_qf[["psms_raw"]]) <- colData(cc_qf)
```

We can also change the names of our samples to simplify our downstream coding
as well as our visualisation. This is done by changing the `colnames`.

```{r}
 ## Change col names to represent the sample
colnames(cc_qf[["psms_raw"]]) <- cc_qf$sample

## Verify
colData(cc_qf[["psms_raw"]])
```

```{r, include=FALSE, eval=TRUE}
save(cc_qf, file = "output/lesson1-4.rda")
```




:::{.callout-exercise}
#### Challenge 3: Miscleavages
{{< level 2 >}}

Work out what the threshold for trypsin miscleavages was during the identification search.

::: {.callout-answer collapse=true}

```{r}
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  as_tibble() %>%
  pull(Number.of.Missed.Cleavages) %>%
  table()
```

We see that during the identification search missed cleavages were limited to a
maximum of 2 missed cleavage sites. This is typical in bottom-up proteomics.

:::
:::


::: {.callout-tip}
#### Key Points

- The `QFeatures` infrastructure provides a convenient and transparent way to store proteomics data across multiple levels.
- A `QFeatures` object stores each data level as a `SummarizedExperiment`, also called an `assay`, with explicit links maintained between features across different `assay`s (e.g., links between all PSMs contributing to a peptide).
- Explicit links between `assay`s are (i) generated automatically when aggregating data using `aggregateFeatures` or (ii) added manually using the `addAssayLinks` function, as we will see later on.
- Within each `SummarizedExperiment` the feature data is stored within the `rowData`, quantitative data in the `assay`, and sample metadata in the `colData`. These slots are accessible using their corresponding functions.
:::

## References {-}