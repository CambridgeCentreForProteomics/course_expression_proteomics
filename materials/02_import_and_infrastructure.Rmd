---
title: Import and infrastructure
bibliography: course_refs.bib
---

::: {.callout-tip}
#### Learning Objectives

* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related
* Know how to import data into a `QFeatures` object 
* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`

:::

```{r, echo = FALSE, fig.align = "center", out.width = "90%"}
knitr::include_graphics("figs/flow_chart/flow_chart.001.png", error = FALSE)
```

## The data structure

MS-based quantitative proteomics data is typically represented as a matrix in
which the rows represent features (PSMs, peptides or proteins) and the columns
contain information about these features, including their quantification
measurements across several samples. As we saw before, this type of quantitative
proteomics matrix can be generated by using third party softwares to process raw
MS data. Moreover, the software usually outputs a quantitative matrix for each
data level (e.g., PSM, peptide, peptide groups, protein groups). In this lesson
we will explain how we can make use of R/Bioconductor packages with dedicated
functions and data structures to store and manipulate quantitative proteomics
data.

We begin with exporting our data at the lowest data-level. In this DDA TMT
experiment this is the PSM level. This .txt file contains for every PSM
identified the relative abundance of each PSMs across each sample as well
as columns with PSM meta-data.

We will be using the Quantitative features for mass spectrometry, or
`QFeatures`, Bioconductor package to import, store, and manipulate our data.
Before we import the data into R using `QFeatures` it is first necessary to
understand the structure of a `QFeatures` object and `SummarizedExperiment`
object.

## The structure of a `SummarizedExperiment`

To simplify the storage of quantitative proteomics data we can store the data as
a [`SummarizedExperiment`](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html)
object (as shown in @fig-summarized-experiment).`SummarizedExperiment` objects
can be conceptualised as data containers made up of three different parts:

1. The `assay` - a matrix which contains the quantitative data from a proteomics
experiment. Each row represents a feature (a PSM, peptide or protein) and each
column contains the quantitative data (measurements) from one experimental
sample.

2. The `rowData` - a table (data frame) which contains all remaining
information derived from an identification search (i.e. every column from your
identification search output that was not a quantification column). Rows 
represent features but columns inform about different attributes of the feature
(e.g., its sequence, name, modifications).

3. The `colData` - a table (data frame) to store sample metadata that would not
appear in the output of your identification search. This could be for example,
the cell line used, which condition, which replicate each sample corresponds to
etc. Again, this information is stored in a matrix-like data structure.

Finally, there is also an additional container called `metadata` which is a
place for users to store experimental metadata. For example, this could be which
instrument the samples were run on, the operators name, the date the samples
were run and so forth. We will focus on populating and understanding the above
3 main containers within a `SummarizedExperiment`. 

```{r fig-summarized-experiment, echo = FALSE, fig.cap = "Diagramatic representation of the structure of a `SummarizedExperiment` object in R (modified from the SummarizedExperiment package)", fig.align = "center", out.width = "90%"}
knitr::include_graphics("figs/summarized-experiment-modified.png", error = FALSE)
```

Data stored in these three main areas can be easily accessed using the `assay()`, 
`rowData()` and `colData()` functions, as we will see later.


## The structure of a `QFeatures` object

Whilst a `SummarizedExperiment` is able to neatly store quantitative proteomics
data at a single data level (i.e., PSM, peptide or protein), a typical data
analysis workflow requires us to look across multiple levels. For example, it is
common to start an analysis with a lower data level and then aggregate upward
towards a final protein-level dataset. Doing this allows for greater flexibility
and understanding of the processes required to clean and aggregate the data.

A [`QFeatures`](https://bioconductor.org/packages/release/bioc/html/QFeatures.html) 
object is essentially a list of `SummarizedExperiment` objects. However, the
main benefit of using a `QFeatures` object over storing each data level as an
independent `SummarizedExperiment` is that the `QFeatures` infrastructure
maintains explicit links between the `SummarizedExperiment`s that it stores.
This allows for maximum traceability when processing data across multiple levels
e.g., tracking which PSMs contribute to each peptide and which peptides
contribute to a protein (@fig-qfeatures, modified from the [`QFeatures` vignette](https://bioconductor.org/packages/release/bioc/vignettes/QFeatures/inst/doc/QFeatures.html)
with permission).


```{r fig-qfeatures, echo = FALSE, fig.cap = "Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.", fig.align = "center", out.width = "90%"}
knitr::include_graphics("figs/qfeatures.png", error = FALSE)
```

:::{.callout-note}
#### QFeatures
When talking about a `QFeatures` object, each dataset (individual
`SummarizedExperiment`) can be referred to as an `experiment assay`. This is not
to be confused with the quantitative matrix section of a `SummarizedExperiment`,
which is also called the `assay` data.
:::

In order to generate the explicit links between data levels, we need to import
the lowest desired data level into a `QFeatures` object and aggregate upwards
within the `QFeatures` infrastructure using the `aggregateFeatures` function, as
we will later see in this course. If two `SummarizedExperiments` are generated
separately and then added into the same `QFeatures` object, there will not
automatically be links between them. In this case, if links are required, we can
manually add links using the `addAssayLink()` function.

The best way to get our head around the `QFeatures` infrastructure is to import
our data into a `QFeatures` object and start exploring. 


## Packages and working directory

During this course we will use several R/Bioconductor packages. 

Let's begin by opening RStudio and loading these packages into our working
environment. 

```{r load_packages, message = FALSE, results = "hide", warning=FALSE}
library("QFeatures")
library("NormalyzerDE")
library("limma")
library("factoextra")
library("org.Hs.eg.db")
library("clusterProfiler")
library("enrichplot")
library("patchwork")
library("tidyverse")
```

Set your working directory to `Course_Materials` where you will find all the
relevant data and R code files for this course. This can be achieved using the
`setwd` function or by going to the menu Session -> Set Working Directory ->
Choose Directory, in RStudio. Type `list.files` into your R console to check
you can see the materials.

## Importing data into R

There are several ways in which data can be imported into a `QFeatures` object.
For example, it is possible to first read the data into a `SummarizedExperiment`
object using the `readSummarizedExperiment()` function, and then import this
`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can 
import our data directly into a `QFeatures` object using the `readQFeatures()`
function. We will use the latter.

Arguments to pass to `readQFeatures`:

* `table` = file path to our data
* `ecol` = an index for columns containing quantitative data. Can be a numeric 
index of the columns or a character vector containing the column names
* `sep` = the file delimiter used (`\t` for tab-delimited `.txt` files and 
`,` for comma separated `.csv` files)
* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`
within the `QFeatures` object

Let's read in the total proteome dataset from our experiment which is has been
output from Proteome Discoverer at the PSM level. The file is called
`cell_cycle_total_proteome_analysis_PSMs.txt`. 

Before we can read in the data we need to first identify which columns the
quantitation data is stored in. The data is a `.txt` file is tab-delimited
so we can use the `read.delim` function and look at the column names.

```{r}
read.delim("data/cell_cycle_total_proteome_analysis_PSMs.txt") %>%
  names()
```

We can see the quantitation data is located in columns 47 - 56 which start with
"Abundance..." followed by the identifying TMT tag. Naming of the abundance
columns is dependent on the third party software used and version, please make
sure you check you identify the relevent column numbers containing the
quantitation data in your own data.

We will pass this information to the `ecol` argument when we use the
`readQFeatures` function. As already mentioned, the `.txt` file is tab-delimited
so we thus pass `sep = "\t"`. As this is the first data import before any
processing so let's call this data level `"psms_raw"`.

```{r}
## Import data into QF object
cc_qf <- readQFeatures(table = "data/cell_cycle_total_proteome_analysis_PSMs.txt",
                       ecol = 47:56, 
                       sep = "\t",
                       name = "psms_raw")
```


::: {.callout-note}
#### Finding help files
During this course we see many new functions. For more information on any R
function type `?` and the name of the function in the R console to bring up
the relevant documentation. Or go to the Help menu in RStudio and 
Help -> Search R Help. For example, to see the help files and documentation for
the `readQFeatures` function type `?readQFeatures` in your RStudio console. The
help documentation highlights what structure the input data should be (a vector,
dataframe or matrix etc.) as well as which arguments are required or optional. 
When using more complex functions, such as those which we will use for statistical
analysis, it is advisable to consult the help documentation to ensure that you 
understand what the function's default parameters are. This will help you to
make sure that the function does what you are expecting it to do.

:::


## Accessing information within a `QFeatures` object

Let's take a look at our newly created object.

```{r}
cc_qf
```

We see that we have created a `QFeatures` object containing a single
`SummarizedExperiment` called "psms_raw". There are `r nrow(cc_qf[["psms_raw"]])`
rows in the data, representing `r nrow(cc_qf[["psms_raw"]])` PSMs. We also see
that there are `r  ncol(cc_qf[["psms_raw"]])` columns representing our 10 samples.

We can access individual `SummarizedExperiment`s within a `QFeatures` object
using standard double bracket nomenclature (this is how you would normally
access items of a `list` in R). As with all indexing we can use the list
position or assay name.


```{r}
## Indexing using position
cc_qf[[1]]

## Indexing using name
cc_qf[["psms_raw"]]
```

Within each `SummarizedExperiment`(SE), the `rowData`, `colData` and `assay`
data are accessed using `rowData()`, `colData()` and `assay()`, respectively.
Let's use these functions to explore the data structure further.

- How has our data been organised within the `QFeatures` object? 

### The `assay` container

Let's start with the quantitation data of our SE called `psms_raw`. This is
stored in the `assay` slot.

```{r, eval=FALSE}
assay(cc_qf[["psms_raw"]])
```

You will see that the R console is populated with the quantitation data and the
whole dataset is too big to print to the screen. Let's use the `head` command to
show only the 6 lines (default) of the quantitation data.

Type into your R console,

```{r}
head(assay(cc_qf[["psms_raw"]]))
```

This is equivalent to,

```{r}
cc_qf[["psms_raw"]] %>% 
  assay() %>% 
  head()
```

The first code chunk uses nested functions and the second uses pipes. Throughout
this course for ease of coding and clarity we will use pipes and where 
appropriate follow the `tidyverse` style of coding for clarity. 

::: {.callout-note}
#### The dplyr pipe
In this course we will frequently use pipes, specifically the `dplyr` pipe part
of the `dplyr` package and `tidyverse`. The pipe operator allows you to chain
together multiple operations and code complex tasks in a more linear and
understandable way, rather than having to nest multiple function calls or write
multiple lines of code. For more information see Hadley Wickham's Tidyverse at
[https://www.tidyverse.org](https://www.tidyverse.org).

:::

:::{.callout-exercise}
#### Challenge 1: Accessing information
{{< level 1 >}}

Explore the `QFeatures` object you have just created. 

1. How many assays do we currently have in the object? 

2. How many PSMs have been identified in the data?

3. How do you access and view the quantitation data i.e. the relative abundance 
of each PSM across the samples?


::: {.callout-answer collapse=true}

**Task 1**

When we type the name of the the object `cc_qf` a summary of the data is 
printed to the screen. This summary shows us a summary of the number of assays
we have in the data.

```{r}
cc_qf
```

Since a `QFeatures` object is a list of `SummarizedExperiment` objects, we can
use `length(cc_qf)` to check how many objects we have inside it

```{r}
length(cc_qf)
```

Alternatively, we can also extract the list of experiments directly using

```{r}
experiments(cc_qf)
```

----

**Task 2**

Similarly, the object summary also tells us the number of PSMs. We can also
extract the number of rows (PSMs in our case) for a given level (i.e. `psms_raw`)

```{r}
cc_qf[["psms_raw"]] %>% 
  nrow()
```

----

**Task 3**

We can use the `assay` accessor,

```{r, eval=FALSE}
cc_qf[["psms_raw"]] %>% 
  assay()
```

or equivalently,

```{r, eval=FALSE}
assay(cc_qf[["psms_raw"]])
```

----

:::
:::

As expected, the `assay` slot contains 10 quantitative columns corresponding to
the 10 samples in our experiment. We see some quantitative values and some 
missing values, here denotated `NA`.

### The `rowData` container

Now let's examine the the `rowData` slot,

```{r}
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  names()
```

The columns of our `rowData` contain non-quantitative information derived from 
the third party identification search. The exact names of variables will differ
between software and change over time, but the key information that we need to
know about each feature (here PSMs) will always be here. 

This information includes the sequence of the peptide to which each PSM
corresponds (`"Sequence"`) as well as the master protein to which the peptide is
assigned (`"Master.Protein.Accessions"`). We will come across more of the
variables stored in the `rowData` when we come to data cleaning and filtering.

We again use the `head` command to print the first 6 rows of the `rowData`

```{r, eval = FALSE}
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  head()
```


:::{.callout-exercise}
#### Challenge 2: Calculating the number of peptides and proteins in our dataset
{{< level 2 >}}

Explore the information stored in the `rowData` from the Proteome Discoverer
search. Look at the first few rows of this data matrix by using the `head`
function and find a column that related to the peptide sequence information.

1. What class is the `rowData` container? How many rows and columns are in 
this data structure?

2. Extract the `rowData` and convert it to a `tibble` or `data.frame`. Find a column that contains information that relates to the peptide sequence. Pull this information and calculate
how many unique peptide sequences we have in the dataset.

<details><summary>Hint</summary> Using the `unique` function may be helpful.</details>

3. How many proteins have been identified in the dataset? 

<details><summary>Hint</summary> Again, convert the `rowData` to a `tibble` or
`data.frame` and find a column that contains information that relates to protein
identification.</details>

::: {.callout-answer collapse=true}

**Task 1**

```{r}
cc_qf[["psms_raw"]] %>% 
  rowData() %>% 
  class()
```

We see that the `rowData` is of class `"DFrame"`. This is a type of data frame.
Will will convert this to a `data.frame` or `tibble` throughout this couse
to make use of `tidyverse` functions.

```{r}
cc_qf[["psms_raw"]] %>% 
  rowData() %>% 
  dim()
```

We see we have `r nrow(rowData(cc_qf[[1]]))` PSMs and `r ncol(rowData(cc_qf[[1]]))`
columns of information relating to each PSM.

----

**Task 2**

There are many ways to extract the number of peptides from our datasets. The
current data level shows the total number of PSMs (peptide spectrum matches).
Although PSMs are fragments of identified peptide sequences, there can be many
PSMs per unique peptide. The `rowData` is where we have stored information relating
to our samples that are not quantitation data. The column `Sequence` contains 
the peptide sequence from which the PSM is is derived. 

In the following lines of code we,
- Extract the `rowData`
- Convert the `rowData` which is `DFrame` to either a `data.frame` or 
`tibble`. We could use the `as.data.frame` or `as_tibble` functions, 
respectively, which we will allow us to use pipes. 
- Extract the column `Sequence`.
- Use the `unique` function to group together PSMs from the same peptide. 
- Finally, we use the `length` command to count the number of peptides.

```{r}
## Using pipes
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  as_tibble() %>%
  pull(Sequence) %>%
  unique() %>%
  length() 
```

Alternative solution (among many others)

```{r}
## Without pipes
rd <- rowData(cc_qf[["psms_raw"]])
tbl <- unique(rd$Sequence) 
length(tbl)
```

We have `r length(tbl)` peptides.

----

**Task 3**

Information regarding the proteins is found in the `Master.Protein.Accessions` column. 

```{r}
## Using pipes
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  as_tibble() %>%
  pull(Master.Protein.Accessions) %>%
  unique() %>%
  length() 
```

Alternative solution (among many others)

```{r}
## Without pipes
tbl <- unique(rd$Master.Protein.Accessions) 
length(tbl)
```

We have `r length(tbl)` proteins.

----

:::
:::

### The `colData` container

The final slot within our `SummarizedExperiment` is the `colData`.

```{r}
cc_qf[["psms_raw"]] %>%
  colData()
```

We see this is also a `DataFrame` structure. 

```{r}
cc_qf[["psms_raw"]] %>%
  colData() %>% 
  class()
```

It has 10 rows, one per sample, but no columns yet. This is because the sample
metadata is not derived from an identification search and does not appear in our
output `.txt` file. If we want to store extra information about our samples, we
need to add this to the `colData` ourselves.

Each row of this 10 by 0 `DataFrame` corresponds to some feature of the 
quantitation channel. The names of these rows are the TMT sample names,

```{r}
cc_qf[["psms_raw"]] %>%
  colData() %>% 
  rownames()
```

### Annotating samples by adding meta-data

The `colData` contains information about the samples. We can create a
`data.frame` in R with information regarding the samples, replicates, conditions
and TMT tag used or we can read in this information into R from a spreadsheet or
.csv. 

Let's open the file `coldata.csv` and then read it into R and add it to
our `QFeatures` object.

```{r}
## Read in coldata .csv
metadata_df <- read.csv("data/samples_meta_data.csv")

## View data
metadata_df
```

This .csv file has 10 rows, importantly the rows are annotated using the
names of the `rowData` of our object, e.g. "Abundance.126", "Abundance.127N" etc.

We can add information from this .csv to our `colData`

```{r}
## Annotate colData with condition information
cc_qf$sample <- metadata_df$sample

## Now add replicate information
cc_qf$rep <- metadata_df$rep

## And condition information
cc_qf$condition <- metadata_df$condition

## Add the TMT information
cc_qf$tag <- metadata_df$tag

## Verify
colData(cc_qf)

## Apply this to the first assay so that it is carried up
colData(cc_qf[["psms_raw"]]) <- colData(cc_qf)
```

We can also change the names of our samples to simplify our downstream coding
as well as our visualisation. This is done by changing the `colnames`.

```{r}
 ## Change col names to represent the sample
colnames(cc_qf[["psms_raw"]]) <- cc_qf$sample

## Verify
colData(cc_qf[["psms_raw"]])
```

```{r, include=FALSE, eval=TRUE}
save(cc_qf, file = "output/lesson02.rda")
```


:::{.callout-exercise}
#### Challenge 3: Miscleavages
{{< level 2 >}}

One of the pieces of information given by the Proteome Discoverer software used
to produce the TMT data is the number of missed cleavages. This is stored in a
`rowData` column named `"Number.of.Missed.Cleavages"`. Can you count how many
occurrences of missed cleavages there are in our data?

::: {.callout-answer collapse=true}

```{r}
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  as_tibble() %>%
  count(Number.of.Missed.Cleavages)
```

We see that during the identification search missed cleavages were limited to a
maximum of 2 missed cleavage sites. This is typical in bottom-up proteomics.

:::
:::


::: {.callout-tip}
#### Key Points

- The `QFeatures` infrastructure provides a convenient and transparent way to 
store proteomics data across multiple levels.
- A `QFeatures` object stores each data level as a `SummarizedExperiment`, 
also called an `assay`, with explicit links maintained between features across 
different `assay`s (e.g., links between all PSMs contributing to a peptide).
- Explicit links between `assay`s are (i) generated automatically when 
aggregating data using `aggregateFeatures` or (ii) added manually using the 
`addAssayLinks` function, as we will see later on.
- Within each `SummarizedExperiment` the feature data is stored within the 
`rowData`, quantitative data in the `assay`, and sample metadata in the 
`colData`. These slots are accessible using their corresponding functions.
:::

## References {-}
