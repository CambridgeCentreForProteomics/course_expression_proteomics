---
title: Import and infrastructure
bibliography: course_refs.bib
---

::: {.callout-tip}
#### Learning Objectives

* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related
* Know how to import data into a `QFeatures` object 
* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`

:::

## The infrastructure

MS-based quantitative proteomics data is typically represented as a matrix in 
which the rows represent features (PSMs, peptides or proteins) and the columns
contain information about these features, including their quantification 
measurements across several samples. As we saw before, this type of quantitative
proteomics matrix can be generated by using third party softwares to process
raw MS data. Moreover, the software usually outputs a quantitative matrix for 
each data level (e.g., PSM, peptide, peptide groups, protein groups).

### The structure of a `SummarizedExperiment`

A commonly used representation of these matrices in R is the `SummarizedExperiment`
structure (as shown in Figure \@ref(fig:summarized-experiment)). To simplify the
storage of such complex data, `SummarizedExperiment` objects can be conceptualised
as data containers made up of three different areas:

1. The `assay` - a matrix-like data structure which contains the quantitative 
data from a proteomics experiment. Each row represents a feature (PSM, peptide or
protein) and each column contains the quantitative data from one experimental 
sample.

2. The `rowData` - a second matrix-like data structure which contains all remaining
information derived from an identification search (i.e., every column from your
identification search output that was not a quantification column). Rows 
represent features but columns inform about different attributes of the feature
(e.g., its sequence, name, modifications).

3. The `colData` - an additional area to store sample metadata that would
not appear in the output of your identification search (e.g., which condition
or replicate each sample corresponds to).

There is also an additional `metadata` compartment for users who wish to store
experimental metadata.

```{r summarized-experiment, echo = FALSE, fig.cap = "Diagramatic representation of the structure of a `SummarizedExperiment` object in R", fig.align = "center", out.width = "100%"}
knitr::include_graphics("figs/summarized-experiment.png", error = FALSE)
```

Data stored in these three areas can be easily accessed using the `assay()`, 
`rowData()` and `colData()` functions, as we will see later.


### The structure of a `QFeatures` object

Whilst a `SummarizedExperiment` is able to neatly store quantitative proteomics
data at a single data level (i.e., PSM, peptide or protein), a typical data
analysis workflow requires us to look across multiple levels. For example, it is
common to start an analysis with a lower data level and then aggregate upward
towards a final protein-level dataset. Doing this allows for greater flexibility
and understanding of the processes required to clean and aggregate the data.

A `QFeatures` object is essentially a list of `SummarizedExperiment` objects.
However, the main benefit of using a `QFeatures` object over storing each data
level as an independent `SummarizedExperiment` is that the `QFeatures` 
infrastructure maintains explicit links between the `SummarizedExperiment`s that 
it stores. This allows for maximum traceability when processing data across 
multiple levels e.g., tracking which PSMs contribute to each peptide and which 
peptides contribute to a protein.


```{r qfeatures, echo = TRUE, fig.cap = "Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.", fig.align = "center", out.width = "100%"}
knitr::include_graphics("figs/qfeatures.png", error = FALSE)
```

**Note**
When talking about a `QFeatures` object, each dataset (individual `SummarizedExperiment`)
can be referred to as an `assay`. This is not to be confused with the quantitative
matrix section of a `SummarizedExperiment`, which is also called the `assay` data.

In order to generate the explicit links between data levels, we need to import
the lowest desired data level into a `QFeatures` object and aggregate upwards
within the `QFeatures` infrastructure using the `aggregateFeatures` function,
as we will later in this course. If two `SummarizedExperiments` are generated 
separately and then added into the same `QFeatures` object, there will not
automatically be links between them. In this case, if links are required, we
can manually add links using the `addAssayLink()` function.

The best way to get our head around the `QFeatures` infrastructure is to import
our data into a `QFeatures` object and start exploring. 

## Working with `QFeatures` in R

### Packages 

During this course we will use several R/Bioconductor packages. 

Let's begin by opening RStudio and loading these packages into our working
environment.

```{r load_packages, message = FALSE, results = "hide"}
library("QFeatures")
library("ggplot2")
library("stringr")
library("dplyr")
library("tibble")
library("NormalyzerDE")
library("corrplot")
library("Biostrings")
library("limma")
library("statmod")
library("org.Hs.eg.db")
library("clusterProfiler")
library("enrichplot")
```

### Working directory

Set your working directory to xxx where you will find the material required for
this course.

### Importing data into R

There are several ways in which data can be imported into a `QFeatures` object.
For example, it is possible to first read the data into a `SummarizedExperiment`
object using the `readSummarizedExperiment()` function, and the import this
`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can 
import our data directly into a `QFeatures` object using the `readQFeatures()`
function.

Arguments to pass to `readQFeatures`:

* `table` = file path to our data
* `ecol` = an index for columns containing quantitative data. Can be a numeric 
index of the columns or a character vector containing the column names
* `sep` = the file delimiter used (`\t` for `.txt` files and `,` for `.csv` files)
* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`
within the `QFeatures` object

```{r}
## Import data into QF object
cc_qf <- readQFeatures(table = "data/cell_cycle_total_proteome_analysis_PSMs.txt",
                    ecol = 47:56, 
                    sep = "\t",
                    name = "psms_raw")
```


### Accessing information within a `QFeatures` object

Let's take a look at our newly created object.

```{r}
## Verify
cc_qf
```

We see that we have created a `QFeatures` object containing a single
`SummarizedExperiment` called "psms_raw". There are `r nrow(cc_qf[["psms_raw"]])`
rows in the data, representing `r nrow(cc_qf[["psms_raw"]])` PSMs. We also see
that there are `r  ncol(cc_qf[["psms_raw"]])` columns representing our 10 samples.

We can access individual `SummarizedExperiment`s within a `QFeatures` object
using standard double bracket nomenclature (this is how you would normally
access items of a `list`). As with all indexing we can use the list position or
assay name. 


```{r}
## Indexing using position
cc_qf[[1]]

## Indexing using name
cc_qf[["psms_raw"]]
```

Within each `SummarizedExperiment, the rowData, colData and assay data are
accessed using `rowData()`, `colData()` and `assay()`, respectively. Let's use
these functions to explore the data structure further.


### How has our data been organised within the `QFeatures` object? 

As outlined above, each `SummarizedExperiment` within the `QFeatures` object 
has a `rowData` slot. Let's take a look at the data stored here.

```{r, eval = FALSE}
## Look at rowData
cc_qf[["psms_raw"]] %>%
  rowData() %>%
  class()
```

The `rowData` is of class `DFrame`. `DFrame` structures behave very similarly to
the base-R `data.frame`. Now let's see what columns our `DFrame` contains.

```{r}
## Look at rowData
cc_qf[["psms_raw"]] %>%
  rowData %>%
  names()
```

The columns of our `rowData` contain non-quantitative information derived from 
the third party identification search. The exact names of variables will differ
between software and change over time, but the key information that we need to
know about each feature (here PSMs) will always be here. This information 
includes the sequence of the peptide to which each PSM corresponds (`"Sequence"`)
as well as the master protein to which the peptide is assigned (`"Master.Protein.Accessions"`).
We will come across more of the variables stored in the `rowData` when we come
to data cleaning and filtering.

We can also take a look at the `assay` data that we have within our "psms_raw"
`SummarizedExperiment`.

```{r}
cc_qf[["psms_raw"]] %>% 
  assay() %>%
  head()
```

As expected, the `assay` slot contains 10 quantitative columns corresponding to
the 10 samples in our experiment. We see some quantitative values and some 
missing values, here denotated `NA`.

The final slot within our `SummarizedExperiment` is the `colData`.

```{r}
cc_qf[["psms_raw"]] %>%
  colData()
```

We have a `DataFrame` structure with 10 rows, one per sample, but no columns yet. 
This is because the sample metadata is not derived from an identification 
search and does not appear in our output `.txt` file. If we want to store extra
information about our samples, we need to add this to the `colData` ourselves.


### Annotating samples by adding meta-data to the `colData`

We can add columns to the `colData` using the `$` operator in the same way as 
a normal `data.frame`.  

```{r}
## Annotate colData with replicate and condition
cc_qf$sample <- c("Control", "M_1", "M_2", "M_3",
                  "G1_1", "G1_2", "G1_3",
                  "DS_1", "DS_2", "DS_3")

cc_qf$rep <- c(NA, rep(1:3, 3))

cc_qf$condition <- c("Pre-treatment", rep(c("M", "G1", "Desynch"), each = 3))

## Verify
colData(cc_qf)

## Apply this to the first assay so that it is carried up
colData(cc_qf[["psms_raw"]]) <- colData(cc_qf)

```

We can also change the names of our samples to simplify our downstream coding
as well as our visualisation. This is done by changing the `colnames`.

```{r}
 ## Change col names to represent the sample
colnames(cc_qf[["psms_raw"]]) <- cc_qf$sample

## Verify
colData(cc_qf[["psms_raw"]])
```

```{r, include=FALSE, eval=TRUE}
save(cc_qf, file = "output/lesson02.rda")
```

#### Challenge: Accessing information from a `QFeatures` object

* Determine how many PSMs, peptides and master proteins are within the data
* Work out what the threshold for trypsin miscleavages was during the identification search


::: {.callout-tip}
#### Key Points

- The `QFeatures` infrastructure provides a convenient and transparent way to store proteomics data across multiple levels.
- A `QFeatures` object stores each data level as a `SummarizedExperiment`, also called an `assay`, with explicit links maintained between features across different `assay`s (e.g., links between all PSMs contributing to a peptide).
- Explicit links between `assay`s are (i) generated automatically when aggregating data using `aggregateFeatures` or (ii) added manually using the `addAssayLinks` function, as we will see later on.
- Within each `SummarizedExperiment` the feature data is stored within the `rowData`, quantitative data in the `assay`, and sample metadata in the `colData`. These slots are accessible using their corresponding functions.
:::

## References {-}