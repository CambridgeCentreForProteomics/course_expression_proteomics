{
  "hash": "8054b7dd0bac4d9ef48cf03b6e909c23",
  "result": {
    "markdown": "---\ntitle: Import and infrastructure\n---\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n* Understand the structure of `SummarizedExperiment` and `QFeatures` objects and how the two are related\n* Know how to import data into a `QFeatures` object \n* Demonstrate how to access information from each part of a `QFeatures` object by indexing and using `assay`, `rowData` and `colData`\n* Understand how explicit links are generated and maintained between assays of a `QFeatures` object\n\n:::\n\n# The infrastructure: `SummarizedExperiment` and `QFeatures` objects\n\nMS-based quantitative proteomics data is typically represented as a matrix in \nwhich the rows represent features (PSMs, peptides or proteins) and the columns\ncontain information about these features, including their quantification \nmeasurements across several samples. As we saw before, this type of quantitative\nproteomics matrix can be generated by using third party softwares to process\nraw MS data. Moreover, the software usually outputs a quantitative matrix for \neach data level (e.g., PSM, peptide, peptide groups, protein groups).\n\n## The structure of a `SummarizedExperiment`\n\nA commonly used representation of these matrices in R is the `SummarizedExperiment`\nstructure (as shown in Figure \\@ref(fig:summarized-experiment)). To simplify the\nstorage of such complex data, `SummarizedExperiment` objects can be conceptualised\nas data containers made up of three different areas:\n\n1. The `assay` - a matrix-like data structure which contains the quantitative \ndata from a proteomics experiment. Each row represents a feature (PSM, peptide or\nprotein) and each column represents an experimental sample.\n\n2. The `rowData` - a second matrix-like data structure which contains all remaining\ninformation derived from an identification search (i.e., every column from your\nidentification search output that was not a quantification column). Rows \nrepresent features but columns inform about different attributes of the feature\n(e.g., its sequence, name, modifications).\n\n3. The `colData` - an additional area to store sample metadata that would\nnot appear in the output of your identification search (e.g., which condition\nor replicate each sample corresponds to).\n\nThere is also an additional `metadata` compartment for users who wish to store\nexperimental metadata.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Diagramatic representation of the structure of a `SummarizedExperiment` object in R](figs/summarized-experiment.png){fig-align='center' width=100%}\n:::\n:::\n\n\nData stored in these three areas can be easily accessed using the `assay()`, \n`rowData()` and `colData()` functions, as we will see later.\n\n\n## The structure of a `QFeatures` object\n\nWhilst a `SummarizedExperiment` is able to neatly store quantitative proteomics\ndata at a single data level (i.e., PSM, peptide or protein), a typical data\nanalysis workflow requires us to look across multiple levels. For example, it is\ncommon to start an analysis with a lower data level and then aggregate upward\ntowards a final protein-level dataset. Doing this allows for greater flexibility\nand understanding of the processes required to clean and aggregate the data.\n\nA `QFeatures` object is essentially a list of `SummarizedExperiment` objects.\nHowever, the main benefit of using a `QFeatures` object over storing each data\nlevel as an independent `SummarizedExperiment` is that the `QFeatures` \ninfrastructure maintains explicit links between the `SummarizedExperiment`s that \nit stores. This allows for maximum traceability when processing data across \nmultiple levels e.g., tracking which PSMs contribute to each peptide and which \npeptides contribute to a protein.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nknitr::include_graphics(\"figs/qfeatures.png\", error = FALSE)\n```\n\n::: {.cell-output-display}\n![Graphic representation of the explicit links between data levels when stored in a `QFeatures` object.](figs/qfeatures.png){fig-align='center' width=100%}\n:::\n:::\n\n\n**Note**\nWhen talking about a `QFeatures` object, each dataset (individual `SummarizedExperiment`)\ncan be referred to as an `assay`. This is not to be confused with the quantitative\nmatrix section of a `SummarizedExperiment`, which is also called the `assay` data.\n\nIn order to generate the explicit links between data levels, we need to import\nthe lowest desired data level into a `QFeatures` object and aggregate upwards\nwithin the `QFeatures` infrastructure using the `aggregateFeatures` function,\nas we will later in this course. If two `SummarizedExperiments` are generated \nseparately and then added into the same `QFeatures` object, there will not\nautomatically be links between them. In this case, if links are required, we\ncan manually add links using the `addAssayLink()` function.\n\nThe best way to get our head around the `QFeatures` infrastructure is to import\nour data into a `QFeatures` object and start exploring. \n\n\n# Importing data into a `QFeatures` object\n\nThere are several ways in which data can be imported into a `QFeatures` object.\nFor example, it is possible to first read the data into a `SummarizedExperiment`\nobject using the `readSummarizedExperiment()` function, and the import this\n`SummarizedExperiment` object into a `QFeatures` object. Alternatively, we can \nimport our data directly into a `QFeatures` object using the `readQFeatures()`\nfunction.\n\nArguments to pass to `readQFeatures`:\n\n* `table` = file path to our data\n* `ecol` = an index for columns containing quantitative data. Can be a numeric \nindex of the columns or a character vector containing the column names\n* `sep` = the file delimiter used (`\\t` for `.txt` files and `,` for `.csv` files)\n* `name` = the name we want to give our first `SummarizedExperiment`, or `assay`\nwithin the `QFeatures` object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"QFeatures\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MultiAssayExperiment\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: SummarizedExperiment\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MatrixGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'MatrixGenerics' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: matrixStats\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MatrixGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomicRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'GenomicRanges' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: stats4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: BiocGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,\n    table, tapply, union, unique, unsplit, which.max, which.min\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: S4Vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'S4Vectors' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'S4Vectors'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: IRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'IRanges' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomeInfoDb\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'GenomeInfoDb' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Biobase\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'Biobase'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'QFeatures'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:MultiAssayExperiment':\n\n    longFormat\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:base':\n\n    sweep\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_qf <- readQFeatures(table = \"data/cell_cycle_total_proteome_analysis_PSMs.txt\",\n                    ecol = 47:56, \n                    sep = \"\\t\",\n                    name = \"psms_raw\")\n```\n:::\n\n\n## How has our data been organised within the `QFeatures` object? \n\n\n\n## Annotating samples by adding meta-data to the `colData`\n\n\n\n\n# Challenge: Accessing information from a `QFeatures` object\n\n* Determine how many PSMs, peptides and master proteins are within the data\n* Work out what the threshold for trypsin miscleavages was during the identification search\n\n::: {.callout-tip}\n#### Key Points\n\n- Last section of the page is a bulleted summary of the key points\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}